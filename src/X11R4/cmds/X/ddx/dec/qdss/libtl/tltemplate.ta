; qdss template routines
;
; CALLING CONVENTIONS
;	Values of the following registers must be set for every template
;	output routine:
;		clipping
;		translation point - use the SETTRANSLATEPOINT macro
;		plane update masks
;	All SET routines end with a GETVD.
;	All packet lists have a DONE at the end.
;	Bank "B" OCR registers are scratch: set them and forget them.
;	Almost all functions assume that SETVIPERS has been called.
;
;	The following registers are assumed to have fixed values, set when
;	    the device is opened; if you mess with them, please put them back:
;	    PLANEMASK: All planes (SET_MASKED_ALU sets LF_R3 to do "logical"
;	    plane masking.)
;	    LF_R1: LF_SOURCE|FULL_SRC_RESOLUTION
;	    RASTEROP_MODE: DST_WRITE_ENABLE|DST_INDEX_ENABLE|NORMAL
;	    ERROR_1, ERROR_2: 0
;	    FAST_DEST_DY, SLOW_DEST_DX: 0
;	    DST_OCR_A, DST_OCR_B: 0
;	    SRC1_OCR_A,SRC2_OCR_A: EXT_NONE|INT_SOURCE|NO_ID|BAR_SHIFT_DELAY
;	    FOREGROUND_COLOR: 0xFFFF
;	    BACKGROUND_COLOR: 0
;	    MASK_1, MASK_2: 0xFFFF
;
;	The following registers are set by InstallState in tldchange.c.
;	They are assumed to have "correct" values for the GC pointed
;	to be the InstalledGC global (unless it is NULL).
;	    SOURCE_2_X, SOURCE_2_Y, SOURCE_2_HEIGHT_AND_WIDTH:
;	        Set to point to tile/stipple, depending on fillStyle.
;	    SRC2_OCR_B: depensd on fillStyle
;
; NOTE:
;	Routines with bitmask sources (text, colorbimap, etc) assume
; the source is in the green zblock.  If this changes, all three
; update masks must be fetched, rather than fetching the green and
; loading 0x00 into red and blue.

;
; Pixels()
; DMA packet:
;	{x,y}*
;
INITPIXELS:
    ; init adder registers
	LOADD SOURCE_1_DX, 1, 1
	LOADD FAST_DEST_DX, 1
	LOADD SLOW_DEST_DY, 1
PIXELS:
	POLL REQUEST_ENABLE,RASTEROP_COMPLETE
	FETCHD DESTINATION_X, 2
	LOADD COMMAND,DTE|LF_R3|RASTEROP
	JMPT PIXELS


;
; FillSpans()
; DMA packet
;	{x,y,dx}*
;
INITFILLSPANS:
    ; init adder registers
        LOADD SLOW_DEST_DY,1
FILLSPANS:
	POLL REQUEST_ENABLE,RASTEROP_COMPLETE
        FETCHD DESTINATION_X, 3
	LOADD COMMAND,DTE|LF_R3|RASTEROP
	JMPT FILLSPANS


; PtoB()
; pixel at a time processor to bitmap transfer (a.k.a Z-mode)
; single channel
; DMA packet
;	x,y,width,height
;	PTB | count
;	{pixval}*
;
INITPTOB:
    ; init adder registers
PTOB:
	FETCHD DESTINATION_X,3
	FETCHD SLOW_DEST_DY
;LOADD COMMAND, PTBZ
	FETCHD COMMAND
	POLL REQUEST_ENABLE, TX_READY
	GETVD		; fetches and decodes the PTB in the DMA packet
	DONE


; ZblockPtoB()
; Z-mode transfer with Z-blocks
; DMA packet
;	x,y,width,height
;	PTBZ | zblock
;	PTB | count
;	{pixval}*
INITZBLOCKPTOB:
    ; init adder registers
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
ZBLOCKPTOB:
	FETCHD DESTINATION_X,3
	FETCHD SLOW_DEST_DY
	POLL REQUEST_ENABLE, TX_READY
	LOADD COMMAND, PTBZ	; better be (PTBZ | zblock)
	GETVD		; fetches and decodes the PTB in the DMA packet
	DONE	;paranoia check


; Blocks()
; DMA packet
;	{x,y,dx,dy}*
;
INITBLOCKS:
    ; init adder registers
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
BLOCKS:
	POLL REQUEST_ENABLE,RASTEROP_COMPLETE
        FETCHD DESTINATION_X, 3
	FETCHD SLOW_DEST_DY
	LOADD COMMAND,DTE|LF_R3|RASTEROP
	JMPT BLOCKS


; NOT USED!
; Fill a rectangle with a repeating power-of-2 size pattern.
; This is preceded by a call to InitFgBgMask() or InitFgMask().
; It uses OCRB.
; the packet contains
;	src2_x, src2_y, src2_size
;	{x,y,w,h}
;
INITFILLPATTERNRECT:
    ; init adder registers
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
	FETCHD SOURCE_2_X, 3
FILLPATTERNRECT:
	POLL REQUEST_ENABLE,RASTEROP_COMPLETE
        FETCHD DESTINATION_X, 3
	FETCHD SLOW_DEST_DY
	LOADD COMMAND,DTE|S2E|OCRB|LF_R3|RASTEROP
	JMPT FILLPATTERNRECT


; ColorBitmap()
; uses a bitmap to put down foreground or foreground and background colors.
; this is much like opaque text.
; Insists on writing into all planes.
; DMA packet
;	source plane
;	{srcx,srcy,dstx,dsty,dx,dy}*

; sets OCRB registers to do a foreground fill with the bitmap in source1.
; The only difference between this routine and the next is the SRC1_OCR_B load
; values.
INIT1COLORBITMAP:
	LOADD SOURCE_1_DX, 1, 1		; for sign only
	    POLL REQUEST_ENABLE, TX_READY
	LOADR SRC1_OCR_B, EXT_M1_M2|NO_ID|BAR_SHIFT_DELAY
	    POLL REQUEST_ENABLE, TX_READY
	FETCHR CS_UPDATE_MASK		; source plane
	    POLL REQUEST_ENABLE, TX_READY
	LOADR RED_UPDATE_MASK, 0x00
	    POLL REQUEST_ENABLE, TX_READY
	LOADR BLUE_UPDATE_MASK, 0x00
	    POLL REQUEST_ENABLE, TX_READY
	LOADR SRC1_OCR_B, EXT_NONE|INT_M1_M2|ID|BAR_SHIFT_DELAY
	    POLL REQUEST_ENABLE, TX_READY
	LOADR GREEN_UPDATE_MASK, 0xFF
	    POLL REQUEST_ENABLE, TX_READY
	LOADR RED_UPDATE_MASK, 0xFF
	    POLL REQUEST_ENABLE, TX_READY
	LOADR BLUE_UPDATE_MASK, 0xFF
	    POLL REQUEST_ENABLE, TX_READY
	GETVD

; sets OCRB registers to do a foreground/background fill with
; the bitmap in source1.
INIT2COLORBITMAP:
	LOADD SOURCE_1_DX, 1, 1		; for sign only
	    POLL REQUEST_ENABLE, TX_READY
	LOADR SRC1_OCR_B, EXT_SOURCE|NO_ID|BAR_SHIFT_DELAY
	    POLL REQUEST_ENABLE, TX_READY
	FETCHR CS_UPDATE_MASK		; source plane
	    POLL REQUEST_ENABLE, TX_READY
	LOADR RED_UPDATE_MASK, 0x00
	    POLL REQUEST_ENABLE, TX_READY
	LOADR BLUE_UPDATE_MASK, 0x00
	    POLL REQUEST_ENABLE, TX_READY
	LOADR SRC1_OCR_B, INT_SOURCE|ID|BAR_SHIFT_DELAY
	    POLL REQUEST_ENABLE, TX_READY
	LOADR GREEN_UPDATE_MASK, 0xFF
	    POLL REQUEST_ENABLE, TX_READY
	LOADR RED_UPDATE_MASK, 0xFF
	    POLL REQUEST_ENABLE, TX_READY
	LOADR BLUE_UPDATE_MASK, 0xFF
	    POLL REQUEST_ENABLE, TX_READY
	GETVD


COLORBITMAP:
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
	FETCHD SOURCE_1_X,5
	FETCHD SLOW_DEST_DY
	LOADD COMMAND, DTE|S1E|OCRB|LF_R3|RASTEROP
	JMPT COLORBITMAP

; Bitblt()
; DMA packet
;	srcdx, srcdy (used to determine direction)
;	srcx,srcy,dstx,dsty,dx,dy
;	{clipx1,clipx2,clipy1.clipy2}*
;
INITBITBLT:
    ; init adder registers
	POLL REQUEST_ENABLE,ADDRESS_COMPLETE
	POLL REQUEST_ENABLE, TX_READY
	FETCHD SOURCE_1_DX,7
	FETCHD SLOW_DEST_DY
BITBLT:
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
	FETCHD X_CLIP_MIN,4
	LOADD COMMAND,DTE|LF_R3|RASTEROP|S1E
	JMPT BITBLT
BITBLTDONE:
	DONE

;
; PolyLine()
; DMA packet:
;	{x,y,dx,dy}*
;
INITPOLYLINE:
	POLL REQUEST_ENABLE, TX_READY
	LOADR MASK_1,0xFFFF
	LOADD SLOW_DEST_DX,1,1
POLYLINE:
	POLL REQUEST_ENABLE,RASTEROP_COMPLETE
	FETCHD DESTINATION_X,4
	LOADD COMMAND,DTE|S2E|OCRB|LF_R3|RASTEROP
	JMPT POLYLINE

;
; FatPolyLine()
; DMA packet:
;	{x,y,dx,dy,slow_dx,slow_dy}*
;
INITFATPOLYLINE:
    ;init adder registers
	LOADD RASTEROP_MODE,DST_WRITE_ENABLE|DST_INDEX_ENABLE|HOLE_ENABLE
FATPOLYLINE:
	POLL REQUEST_ENABLE,RASTEROP_COMPLETE
	FETCHD DESTINATION_X,6
	LOADD COMMAND,DTE|LF_R3|RASTEROP
	JMPT FATPOLYLINE

;
; PatternPolyLine()
; this is prepared for by calling InitFgBgMask() or InitFgMask()
; DMA packet:
;	pat.w, pat.h, pat.x, pat.y
;	{x,y,dx,dy}*
;
INITPATTERNPOLYLINE:
    ;init adder registers
	POLL REQUEST_ENABLE, TX_READY
	LOADR MASK_1,0xFFFF
	LOADD SLOW_DEST_DX,1,1
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
	FETCHD SOURCE_1_DX, 4
	LOADD RASTEROP_MODE,DST_WRITE_ENABLE|DST_INDEX_ENABLE|LINEAR_PATTERN
PATTERNPOLYLINE:
	POLL REQUEST_ENABLE,RASTEROP_COMPLETE
        FETCHD DESTINATION_X, 4
	LOADD COMMAND,DTE|S1E|S2E|OCRB|LF_R3|RASTEROP
	JMPT PATTERNPOLYLINE

;
; ConvexPoly()
; see QDconpoly.c for a description of the DMA packet
;
INITCONPOLY:
    ; init adder registers
	LOADD RASTEROP_MODE,DST_WRITE_ENABLE|DST_INDEX_ENABLE|X_FILL
	FETCHD SOURCE_1_X
	FETCHD DESTINATION_X,2		; gets Y too
A_LE_B:					; reload A edge
	POLL REQUEST_ENABLE, RASTEROP_COMPLETE
	FETCHD SLOW_DEST_DX, 2		; may be jump to B_LE_A,
					; otherwise gets DY too
B_LE_A:					; reload B edge
	POLL REQUEST_ENABLE, RASTEROP_COMPLETE
	FETCHD SOURCE_1_DX, 2		; may be a jump to DOCONPOLY,
					; otherwise gets DY too
CONPOLY:
	LOADD COMMAND, DTE|LF_R3|RASTEROP
	JMPT A_LE_B

; NOT USED!
; ConvexPoly()
; see QDconpoly.c for a description of the DMA packet
;
INITCONPOLYPATTERN:
    ; init adder registers
	FETCHD SOURCE_2_X, 3
	LOADD RASTEROP_MODE,DST_WRITE_ENABLE|DST_INDEX_ENABLE|X_FILL
	FETCHD SOURCE_1_X
	FETCHD DESTINATION_X,2		; gets Y too
A_LE_B_PATTERN:				; reload A edge
	POLL REQUEST_ENABLE, RASTEROP_COMPLETE
	FETCHD SLOW_DEST_DX, 2		; may be jump to B_LE_A,
					; otherwise gets DY too
B_LE_A_PATTERN:				; reload B edge
	POLL REQUEST_ENABLE, RASTEROP_COMPLETE
	FETCHD SOURCE_1_DX, 2		; may be a jump to DOCONPOLY,
					; otherwise gets DY too
CONPOLYPATTERN:
	LOADD COMMAND,DTE|S2E|OCRB|LF_R3|RASTEROP
	JMPT A_LE_B_PATTERN

;
; ScrollClear()
;	Scroll clears the passed rectangle to the current
;	scroll fill color, under the current scroll mask
;	written by ted june 86.
;
SCROLLCLEAR:
	FETCHD SCROLL_X_MIN, 4
	LOADD STATUS, (0x3fff & ~FRAME_SYNC)
	POLL REQUEST_ENABLE, FRAME_SYNC
	LOADD Y_SCROLL_CONSTANT, SCROLL_ERASE
	LOADD STATUS, (0x3fff & ~FRAME_SYNC)
	GETVD

;
; Clear() - old old old
;
CLEAR:
	LOADD SCROLL_X_MIN, 0, 1024, 0, 864, 860
	LOADD STATUS, (0x3fff & ~FRAME_SYNC)
	LOADD REQUEST_ENABLE, FRAME_SYNC
	LOADD Y_SCROLL_CONSTANT, SCROLL_ERASE
	LOADD STATUS, (0x3fff & ~FRAME_SYNC)
	DONE


;
; ShadeSpan()
;
INITSHADESPAN:
	; init adder registers
	LOADD SLOW_DEST_DY,1
	LOADD SOURCE_1_DY,1

	; jump here if everything is already set up
SHADESPAN:
	POLL REQUEST_ENABLE,RASTEROP_COMPLETE
	FETCHD SOURCE_1_DX,1
	FETCHD SOURCE_1_X,2
	FETCHD DESTINATION_X,3
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
	FETCHD FAST_SCALE,1

	LOADD COMMAND,S1E|DTE|LF_R3|RASTEROP
	JMPT SHADESPAN

	; jump to here to clean up after ShadeSpan()
CLEANSHADESPAN:
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
	LOADD FAST_SCALE,0x1fff
	DONE

;
; ShadeLine()
;
INITSHADELINE:
	; init adder registers
	LOADD SLOW_DEST_DY,1
	LOADD SOURCE_1_DY,1

	; jump here if everything is already set up
SHADELINE:
	POLL REQUEST_ENABLE,RASTEROP_COMPLETE
	FETCHD SOURCE_1_DX,1
	FETCHD SOURCE_1_X,6
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
	FETCHD FAST_SCALE,1

	LOADD COMMAND,S1E|DTE|LF_R3|RASTEROP
	JMPT SHADELINE

	; jump to here to clean up after ShadeLine()
CLEANSHADELINE:
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
	LOADD FAST_SCALE,0x1fff
	DONE


;
; SwapInit()
;	Initialize the chipset for double buffering.
;
SWAPINIT:
	LOADD SCROLL_X_MIN, 0, 1024, 0, 864, 860
	LOADD X_CLIP_MIN, 0, 1024, (-864 & 0x3fff), 2048
	LOADD Y_LIMIT, 1728
	LOADD STATUS, (0x3fff & ~FRAME_SYNC)
	LOADD REQUEST_ENABLE, FRAME_SYNC

	LOADD Y_OFFSET_PENDING, 864
	LOADD STATUS, (0x3fff & ~FRAME_SYNC)
	LOADD STATUS, (0x3fff & ~VSYNC)
	LOADD REQUEST_ENABLE, VSYNC

	LOADD Y_SCROLL_CONSTANT, SCROLL_ENABLE
	LOADD Y_INDEX_PENDING, 864
	LOADD Y_OFFSET_PENDING, 0
	LOADD STATUS, (0x3fff & ~FRAME_SYNC)
	LOADD REQUEST_ENABLE, FRAME_SYNC
	LOADD STATUS, (0x3fff & ~VSYNC)
	LOADD REQUEST_ENABLE, VSYNC

	DONE

;
; SwapDone()
;
; 	Jump to INITSWAPDONE: if your writebuffer was 864 to 1024 (1)
;	at the time of swap termination, otherwise jump to SWAPDONE:.
;
;	This code is currently busted because its supposed to copy
;	buffer one into buffer zero but, but it doesnt.
;	It will leave the chipset in the right state for single
;	buffering though.  What should the default clip and scroll
;	rects be ?
;
INITSWAPDONE:
	LOADD Y_OFFSET_PENDING, 0
	LOADD STATUS, (0x3fff & ~FRAME_SYNC)
	LOADD REQUEST_ENABLE, FRAME_SYNC
	LOADD STATUS, (0x3fff & ~FRAME_SYNC)

	LOADD Y_SCROLL_CONSTANT, (0x400 | 864)
	LOADD STATUS, (0x3fff & ~FRAME_SYNC)
	LOADD STATUS, (0x3fff & ~FRAME_SYNC)

SWAPDONE:
	LOADD SCROLL_X_MIN, 0, 1024, 0, 864
	LOADD X_CLIP_MIN, 0, 1024, (-864 & 0x3fff), 2048
	LOADD Y_LIMIT, 1728
	LOADD Y_INDEX_PENDING, 0
	LOADD Y_OFFSET_PENDING, 0
	LOADD STATUS, (0x3fff & ~FRAME_SYNC)
	LOADD STATUS, (0x3fff & ~FRAME_SYNC)

	DONE

;
; SwapBuffer()
;	Depending on the previous writebuffer, clear the new 
;	writebuffer and set up to display the new old.
;
SWAPBUFFER0:
	LOADD STATUS, (0x3fff & ~PAUSE_COMPLETE)
	LOADD REQUEST_ENABLE, PAUSE_COMPLETE
;	LOADD STATUS, (0x3fff & ~FRAME_SYNC)
;	LOADD REQUEST_ENABLE, FRAME_SYNC
	
;
;	Clear the write buffer
;
	LOADD Y_SCROLL_CONSTANT, SCROLL_ERASE
	LOADD Y_OFFSET_PENDING, 864
	LOADD Y_INDEX_PENDING, 0
	LOADD STATUS, (0x3fff & ~FRAME_SYNC)
	LOADD REQUEST_ENABLE, FRAME_SYNC

	LOADD Y_INDEX_PENDING, (-864 & 0x3fff)
	LOADD Y_INDEX_NEW, (-864 & 0x3fff)
	LOADD Y_INDEX_OLD, (-864 & 0x3fff)
	LOADD STATUS, (0x3fff & ~VSYNC)
	LOADD REQUEST_ENABLE, VSYNC

	DONE

SWAPBUFFER1:
	LOADD STATUS, (0x3fff & ~PAUSE_COMPLETE)
	LOADD REQUEST_ENABLE, PAUSE_COMPLETE
;	LOADD STATUS, (0x3fff & ~FRAME_SYNC)
;	LOADD REQUEST_ENABLE, FRAME_SYNC

;
;	Clear the write buffer
;
	LOADD Y_SCROLL_CONSTANT, SCROLL_ERASE
	LOADD Y_OFFSET_PENDING, 0
	LOADD Y_INDEX_PENDING, 0
	LOADD STATUS, (0x3fff & ~FRAME_SYNC)
	LOADD REQUEST_ENABLE, FRAME_SYNC

	LOADD Y_INDEX_PENDING,864
	LOADD Y_INDEX_NEW,864
	LOADD Y_INDEX_OLD,864
	LOADD STATUS, (0x3fff & ~VSYNC)
	LOADD REQUEST_ENABLE, VSYNC

	DONE


;
; SetColor()
; this sets SOURCE_Z to a value from the fifo.  since llge's notion
; of rasterops is bitwise combination, rather than the combination
; of two masks and two colors, the llge combining functions will
; work only if FOREGROUND_Z and BACKGROUND_Z are 0xffff and 0x0000,
; respectively, and SOURCE_Z is the color to draw in.
;
SETCOLOR:
    ZBLOCK 0
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
	POLL REQUEST_ENABLE, TX_READY
	FETCHR SOURCE_Z
	GETVD

SETRGBCOLOR:
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
    ZBLOCK ZBLOCK_RED
	POLL REQUEST_ENABLE, TX_READY
	FETCHR SOURCE_Z
    ZBLOCK ZBLOCK_GREEN
	POLL REQUEST_ENABLE, TX_READY
	FETCHR SOURCE_Z
    ZBLOCK ZBLOCK_BLUE
	POLL REQUEST_ENABLE, TX_READY
	FETCHR SOURCE_Z
    ZBLOCK 0
	GETVD

;
; SetRgbScrollFill()
; 	This routine sets the current scroll fill color for
;	doing fast scroll clears of rectangles in QZclear().
;	Written by ted june 86.
;
SETRGBSCROLLFILL:
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
    ZBLOCK ZBLOCK_RED
	POLL REQUEST_ENABLE, ID_SCROLL_READY
	FETCHSR SCROLL_FILL_Z
    ZBLOCK ZBLOCK_GREEN
	POLL REQUEST_ENABLE, ID_SCROLL_READY
	FETCHSR SCROLL_FILL_Z
    ZBLOCK ZBLOCK_BLUE
	POLL REQUEST_ENABLE, ID_SCROLL_READY
	FETCHSR SCROLL_FILL_Z
    ZBLOCK 0
	GETVD

;
; Sets all viper foreground and background colors, for template
; routines which must use this model.
; used by textterm, fillcoloredmask, and colorbitmap
;
SETFOREBACKCOLOR:
    ZBLOCK 0
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
	POLL REQUEST_ENABLE, TX_READY
	FETCHR FOREGROUND_COLOR_Z	; foreground
	POLL REQUEST_ENABLE, TX_READY
	FETCHR BACKGROUND_COLOR_Z	; background
	GETVD

; DMA packet
;	fore.r, fore.g, fore.b
;	back.r, back.g, back.b

SETRGBFOREBACKCOLOR:
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
    ZBLOCK ZBLOCK_RED
	POLL REQUEST_ENABLE, TX_READY
	FETCHR FOREGROUND_COLOR_Z	; foreground red
    ZBLOCK ZBLOCK_GREEN
	POLL REQUEST_ENABLE, TX_READY
	FETCHR FOREGROUND_COLOR_Z	; foreground green
    ZBLOCK ZBLOCK_BLUE
	POLL REQUEST_ENABLE, TX_READY
	FETCHR FOREGROUND_COLOR_Z	; foreground blue
    ZBLOCK ZBLOCK_RED
	POLL REQUEST_ENABLE, TX_READY
	FETCHR BACKGROUND_COLOR_Z	; background red
    ZBLOCK ZBLOCK_GREEN
	POLL REQUEST_ENABLE, TX_READY
	FETCHR BACKGROUND_COLOR_Z	; background green
    ZBLOCK ZBLOCK_BLUE
	POLL REQUEST_ENABLE, TX_READY
	FETCHR BACKGROUND_COLOR_Z	; background blue
	GETVD
    ZBLOCK 0

;
; SetViper()
; sets LU_FUNCTION_R3 to a value from the fifo, the
; rest of the viper registers to a useful and well-known state
;
SETVIPER:
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
	POLL REQUEST_ENABLE, TX_READY
	FETCHR LU_FUNCTION_R3
	POLL REQUEST_ENABLE, TX_READY
	LOADR SOURCE,0xFFFF
	GETVD


SETVIPER24:
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
	POLL REQUEST_ENABLE, TX_READY
	FETCHR LU_FUNCTION_R3
	POLL REQUEST_ENABLE, TX_READY
	LOADR SOURCE,0xFFFF
	GETVD

;
; SetClip()
; sets the clipping registers
; DMA packet
;	x_min, x_max, y_min, y_max
;
SETCLIP:
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
	FETCHD X_CLIP_MIN, 4
	GETVD

; ResetClip()
; sets clipping to the entire frame buffer
;
RESETCLIP:
;	LOADD X_CLIP_MIN, 0, 1024, 0, 2048
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
	LOADD X_CLIP_MIN, 0, 1024, (-864 & 0x3fff), 2048
	GETVD

;
; SetPlaneMask();
; sets the plane mask to a value from the fifo
SETPLANEMASK:
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
	POLL REQUEST_ENABLE, TX_READY
	FETCHR CS_UPDATE_MASK
	GETVD

SETREDPLANEMASK:
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
	POLL REQUEST_ENABLE, TX_READY
	FETCHR RED_UPDATE_MASK
	GETVD

SETGREENPLANEMASK:
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
	POLL REQUEST_ENABLE, TX_READY
	FETCHR GREEN_UPDATE_MASK
	GETVD

SETBLUEPLANEMASK:
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
	POLL REQUEST_ENABLE, TX_READY
	FETCHR BLUE_UPDATE_MASK
	GETVD

SETRGBPLANEMASK:
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
	POLL REQUEST_ENABLE, TX_READY
	FETCHR RED_UPDATE_MASK
	POLL REQUEST_ENABLE, TX_READY
	FETCHR GREEN_UPDATE_MASK
	POLL REQUEST_ENABLE, TX_READY
	FETCHR BLUE_UPDATE_MASK
	GETVD
;
;	Set the Scroll Enable bits on the Vipers.
;	This code assumes that the Scroll Mask is already
;	set to all 1's.
;
SETRGBSCROLLENABLE:
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
	POLL REQUEST_ENABLE, ID_SCROLL_READY
	LOADSR GREEN_SCROLL_MASK, 0x0
	POLL REQUEST_ENABLE, ID_SCROLL_READY
	LOADSR BLUE_SCROLL_MASK, 0x0
	POLL REQUEST_ENABLE, ID_SCROLL_READY
	FETCHSR SCROLL_CONSTANT
	POLL REQUEST_ENABLE, ID_SCROLL_READY
	LOADSR RED_SCROLL_MASK, 0x0
	POLL REQUEST_ENABLE, ID_SCROLL_READY
	LOADSR GREEN_SCROLL_MASK, 0xff
	POLL REQUEST_ENABLE, ID_SCROLL_READY
	FETCHSR SCROLL_CONSTANT
	POLL REQUEST_ENABLE, ID_SCROLL_READY
	LOADSR GREEN_SCROLL_MASK, 0x0
	POLL REQUEST_ENABLE, ID_SCROLL_READY
	LOADSR BLUE_SCROLL_MASK, 0xff
	POLL REQUEST_ENABLE, ID_SCROLL_READY
	FETCHSR SCROLL_CONSTANT
	POLL REQUEST_ENABLE, ID_SCROLL_READY
	LOADSR RED_SCROLL_MASK, 0xff
	POLL REQUEST_ENABLE, ID_SCROLL_READY
	LOADSR GREEN_SCROLL_MASK, 0xff
	GETVD

;
;	Set the translation point (index registers).
;	This will be a seperate packet instead of coming
;	with each output primitive.  It need only be used
;	at a context switch between windows.
;
SETTRANSLATE:
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
	FETCHD X_INDEX_PENDING, 6
	GETVD


; single plane processor to bitmap transfer (a.k.a. xy-mode)
; DMA packet
;	maskplane
;	x,y,width,height
;	PTB | count
;	{pixval}*
;
; Setup for transfer
;	Note the SCR1_OCR_B load commands the viper to:
;		1. load the SOURCE register from the ID bus
;		2. load NO registers from the destination memory
;		3. transmit NO data on the ID bus between cycles
;		4. NOT load the barrel shift delay register
;	The SOURCE register is automatically used to write to
;	the destination memory location because LF_R1 is selected
;	in the Adder command, and this control register 
;	was loaded with (FULL_SRC_RESOLUTION | LF_SOURCE)
;	Setting the DTE bit in the adder command is necessary.

PTOBXY:
    ; init adder registers
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
; For some reason, setting the plane mask is necessary
POLL REQUEST_ENABLE, TX_READY
FETCHR CS_UPDATE_MASK		; now select just the dest vipers
POLL REQUEST_ENABLE, TX_READY	; added by dwm
	LOADR SRC1_OCR_B,EXT_SOURCE|BAR_SHIFT_DELAY
	POLL REQUEST_ENABLE, TX_READY
	FETCHD DESTINATION_X,3		; x, y, width
	FETCHD SLOW_DEST_DY		; height
	POLL REQUEST_ENABLE, TX_READY
	LOADD COMMAND, PBT|DTE|LF_R3|SELECT_SRC1_OCR_B
	GETVD		; fetches and decodes the PTB in the DMA packet
PTOBXYCLEAN:
POLL REQUEST_ENABLE, ADDRESS_COMPLETE
POLL REQUEST_ENABLE, TX_READY
LOADR GREEN_UPDATE_MASK, 0xFF
	POLL REQUEST_ENABLE, TX_READY
	DONE

; Same as PTOBXY, except for the SRC1_OCR_B value
PTOBXYMASK:
    ; init adder registers
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
	POLL REQUEST_ENABLE, TX_READY
	FETCHR CS_UPDATE_MASK		; now select just the dest vipers
	POLL REQUEST_ENABLE, TX_READY	; added by dwm
	LOADR SRC1_OCR_B,EXT_M2|BAR_SHIFT_DELAY
	POLL REQUEST_ENABLE, TX_READY
	FETCHD DESTINATION_X,3		; x, y, width
	FETCHD SLOW_DEST_DY		; height
	POLL REQUEST_ENABLE, TX_READY
	LOADD COMMAND, PBT|DTE|LF_R3|SELECT_SRC1_OCR_B
	GETVD		; fetches and decodes the PTB in the DMA packet

; Performs the following
;	- single and multi-plane transfers to off-screen
;	- image output using logical functions
PTOBXY24:
    ; init adder registers
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
	POLL REQUEST_ENABLE, TX_READY
    FETCHR RED_UPDATE_MASK
	POLL REQUEST_ENABLE, TX_READY
    FETCHR GREEN_UPDATE_MASK
	POLL REQUEST_ENABLE, TX_READY
    FETCHR BLUE_UPDATE_MASK
	POLL REQUEST_ENABLE, TX_READY
    LOADR SRC1_OCR_B,EXT_SOURCE|BAR_SHIFT_DELAY
	POLL REQUEST_ENABLE, TX_READY
    FETCHD DESTINATION_X,3		; x, y, width
    FETCHD SLOW_DEST_DY		; height
	POLL REQUEST_ENABLE, TX_READY
    LOADD COMMAND, PBT|DTE|LF_R3|SELECT_SRC1_OCR_B
    GETVD		; fetches and decodes the PTB in the DMA packet
PTOBXY24CLEAN:
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
	POLL REQUEST_ENABLE, TX_READY
    LOADR GREEN_UPDATE_MASK, 0xFF
	POLL REQUEST_ENABLE, TX_READY
    LOADR RED_UPDATE_MASK, 0xFF
	POLL REQUEST_ENABLE, TX_READY
    LOADR BLUE_UPDATE_MASK, 0xFF
	POLL REQUEST_ENABLE, TX_READY
	DONE

; Combination of PTOBXY24 PTOBMASK
PTOBXY24MASK:
    ; init adder registers
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
	POLL REQUEST_ENABLE, TX_READY
    FETCHR RED_UPDATE_MASK
	POLL REQUEST_ENABLE, TX_READY
    FETCHR GREEN_UPDATE_MASK
	POLL REQUEST_ENABLE, TX_READY
    FETCHR BLUE_UPDATE_MASK
	POLL REQUEST_ENABLE, TX_READY
    LOADR SRC1_OCR_B,EXT_M2|BAR_SHIFT_DELAY
	POLL REQUEST_ENABLE, TX_READY
    FETCHD DESTINATION_X,3		; x, y, width
    FETCHD SLOW_DEST_DY		; height
	POLL REQUEST_ENABLE, TX_READY
    LOADD COMMAND, PBT|DTE|LF_R3|SELECT_SRC1_OCR_B
    GETVD		; fetches and decodes the PTB in the DMA packet

; Mask text
; DMA packet:
;	dx, dy, fontplane, dest_y,
;	{source_x, source_y, dest_x}*
;
; Insists on writing text into all planes.
;

INITTEXTMASK:
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
	LOADD SOURCE_1_DX,1,1
	FETCHD FAST_DEST_DX,1		; dx
	FETCHD SLOW_DEST_DY,1		; dy
	    POLL REQUEST_ENABLE, TX_READY
	LOADR SRC1_OCR_B, EXT_M1_M2|INT_NONE|NO_ID|BAR_SHIFT_DELAY
	    POLL REQUEST_ENABLE, TX_READY
	FETCHR CS_UPDATE_MASK		; fontplane
	    POLL REQUEST_ENABLE, TX_READY
	LOADR SRC1_OCR_B, EXT_NONE|INT_M1_M2|ID|BAR_SHIFT_DELAY
	    POLL REQUEST_ENABLE, TX_READY
	LOADR CS_UPDATE_MASK, 0xff
	    POLL REQUEST_ENABLE, TX_READY
	FETCHD DESTINATION_Y,1		; dest_y
TEXTMASK:
	POLL REQUEST_ENABLE,RASTEROP_COMPLETE
	FETCHD SOURCE_1_X,2
	FETCHD DESTINATION_X,1
	LOADD COMMAND, DTE|S1E|S2E|OCRB|LF_R3|RASTEROP
	JMPT TEXTMASK

; TEXTMASK differs from TEXTSOLID only in that the former enables S2.

INITTEXTSOLID:
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
	LOADD SOURCE_1_DX,1,1
	FETCHD FAST_DEST_DX,1		; dx
	FETCHD SLOW_DEST_DY,1		; dy
	    POLL REQUEST_ENABLE, TX_READY
	LOADR SRC1_OCR_B, EXT_M1_M2|INT_NONE|NO_ID|BAR_SHIFT_DELAY
	    POLL REQUEST_ENABLE, TX_READY
	FETCHR CS_UPDATE_MASK		; fontplane
	    POLL REQUEST_ENABLE, TX_READY
	LOADR SRC1_OCR_B, EXT_NONE|INT_M1_M2|ID|BAR_SHIFT_DELAY
	    POLL REQUEST_ENABLE, TX_READY
	LOADR CS_UPDATE_MASK, 0xff
	    POLL REQUEST_ENABLE, TX_READY
	FETCHD DESTINATION_Y,1		; dest_y
TEXTSOLID:
	POLL REQUEST_ENABLE,RASTEROP_COMPLETE
	FETCHD SOURCE_1_X,2
	FETCHD DESTINATION_X,1
	LOADD COMMAND, DTE|S1E|OCRB|LF_R3|RASTEROP
	JMPT TEXTSOLID

; Terminal emulator text
; 
; DMA packet:
;	dx, dy, fontplane, dest_y,
;	{source_x, source_y, dest_x}*
;
; The only difference between this routine and the previous
; is the SRC1_OCR_B load value.
; Insists on writing text into all planes.
; 
INITTEXTTERM:
	    POLL REQUEST_ENABLE, ADDRESS_COMPLETE
	LOADD SOURCE_1_DX,1,1
	FETCHD FAST_DEST_DX,1		; dx
	FETCHD SLOW_DEST_DY,1		; dy
	    POLL REQUEST_ENABLE, TX_READY
	LOADR SRC1_OCR_B, EXT_SOURCE|INT_NONE|NO_ID|BAR_SHIFT_DELAY
	    POLL REQUEST_ENABLE, TX_READY
	FETCHR CS_UPDATE_MASK	; fontplane
	    POLL REQUEST_ENABLE, TX_READY
	LOADR SRC1_OCR_B, INT_SOURCE|ID|BAR_SHIFT_DELAY
            POLL REQUEST_ENABLE, TX_READY
        LOADR CS_UPDATE_MASK, 0xff
            POLL REQUEST_ENABLE, TX_READY
	FETCHD DESTINATION_Y,1		; dest_y
TEXTTERM:
	POLL REQUEST_ENABLE,RASTEROP_COMPLETE
	FETCHD SOURCE_1_X,2
	FETCHD DESTINATION_X,1
	LOADD COMMAND, DTE|S1E|OCRB|LF_R3|RASTEROP
	JMPT TEXTTERM

;
; Anti-aliased text hack
;
INITTEXTAA:
	    POLL REQUEST_ENABLE, ADDRESS_COMPLETE
	    POLL REQUEST_ENABLE, TX_READY
	; fix up this register which SETV24OPAQUE sets up wrong
	LOADR SRC1_OCR_B, INT_SOURCE|NO_ID|BAR_SHIFT_DELAY
	    POLL REQUEST_ENABLE, TX_READY
	LOADD SOURCE_1_DX,1,1
	FETCHD FAST_DEST_DX,1		; dx
	FETCHD SLOW_DEST_DY,1		; dy
	FETCHD SOURCE_1_Y,1		; source_y
	FETCHD DESTINATION_Y,1		; dest_y
	POLL REQUEST_ENABLE,ADDRESS_COMPLETE
TEXTAA:
	POLL REQUEST_ENABLE,RASTEROP_COMPLETE
	FETCHD SOURCE_1_X,1
	FETCHD DESTINATION_X,1
	LOADD COMMAND, DTE|S1E|OCRB|LF_R3|RASTEROP
	JMPT TEXTAA


; utility routines
; these set up OCRB to do a foreground/backgound write with mask or
; a color and transparent writewith mask.
; the mask is assumed to be referenced by the source_2 registers

; InitFgBgMask()
; sets OCRB registers to do a foreground/background fill with
; the mask in source2.
; DMA packet:
;	GREEN_UPDATE_MASK

INITFGBGMASK:
	POLL REQUEST_ENABLE, TX_READY
	LOADR SRC2_OCR_B, EXT_SOURCE|NO_ID|BAR_SHIFT_DELAY
	POLL REQUEST_ENABLE, TX_READY
	FETCHR CS_UPDATE_MASK
	POLL REQUEST_ENABLE, TX_READY
	LOADR RED_UPDATE_MASK, 0x00
	POLL REQUEST_ENABLE, TX_READY
	LOADR BLUE_UPDATE_MASK, 0x00
	POLL REQUEST_ENABLE, TX_READY
	LOADR SRC2_OCR_B, INT_SOURCE|ID|BAR_SHIFT_DELAY
	POLL REQUEST_ENABLE, TX_READY
	LOADR GREEN_UPDATE_MASK, 0xFF
	POLL REQUEST_ENABLE, TX_READY
	LOADR RED_UPDATE_MASK, 0xFF
	POLL REQUEST_ENABLE, TX_READY
	LOADR BLUE_UPDATE_MASK, 0xFF
	GETVD


; InitFgMask()
; sets OCRB registers to do a foreground/background fill with
; the mask in source2.
; DMA packet:
;	GREEN_UPDATE_MASK

INITFGMASK:
	POLL REQUEST_ENABLE, TX_READY
	LOADR SRC2_OCR_B, EXT_M2|NO_ID|BAR_SHIFT_DELAY
	POLL REQUEST_ENABLE, TX_READY
	FETCHR CS_UPDATE_MASK
	POLL REQUEST_ENABLE, TX_READY
	LOADR RED_UPDATE_MASK, 0x00
	POLL REQUEST_ENABLE, TX_READY
	LOADR BLUE_UPDATE_MASK, 0x00
	POLL REQUEST_ENABLE, TX_READY
	LOADR SRC2_OCR_B, INT_M2|ID|BAR_SHIFT_DELAY
	POLL REQUEST_ENABLE, TX_READY
	LOADR GREEN_UPDATE_MASK, 0xFF
	POLL REQUEST_ENABLE, TX_READY
	LOADR RED_UPDATE_MASK, 0xFF
	POLL REQUEST_ENABLE, TX_READY
	LOADR BLUE_UPDATE_MASK, 0xFF
	GETVD

; InitFgBgLine()
; sets OCRB registers to do a foreground/background fill with
; the mask in source1.
; DMA packet:
;	GREEN_UPDATE_MASK

INITFGBGLINE:
	POLL REQUEST_ENABLE, TX_READY
	LOADR SRC1_OCR_B, EXT_SOURCE|NO_ID|BAR_SHIFT_DELAY
	POLL REQUEST_ENABLE, TX_READY
	FETCHR CS_UPDATE_MASK
	POLL REQUEST_ENABLE, TX_READY
	LOADR RED_UPDATE_MASK, 0x00
	POLL REQUEST_ENABLE, TX_READY
	LOADR BLUE_UPDATE_MASK, 0x00
	POLL REQUEST_ENABLE, TX_READY
	LOADR SRC1_OCR_B, INT_SOURCE|ID|BAR_SHIFT_DELAY
	POLL REQUEST_ENABLE, TX_READY
	LOADR GREEN_UPDATE_MASK, 0xFF
	POLL REQUEST_ENABLE, TX_READY
	LOADR RED_UPDATE_MASK, 0xFF
	POLL REQUEST_ENABLE, TX_READY
	LOADR BLUE_UPDATE_MASK, 0xFF
	GETVD


; InitFgLine()
; sets OCRB registers to do a foreground/background fill with
; the mask in source1.
; DMA packet:
;	GREEN_UPDATE_MASK

INITFGLINE:
	POLL REQUEST_ENABLE, TX_READY
	LOADR SRC1_OCR_B, EXT_M1_M2|NO_ID|BAR_SHIFT_DELAY
	POLL REQUEST_ENABLE, TX_READY
	FETCHR CS_UPDATE_MASK
	POLL REQUEST_ENABLE, TX_READY
	LOADR RED_UPDATE_MASK, 0x00
	POLL REQUEST_ENABLE, TX_READY
	LOADR BLUE_UPDATE_MASK, 0x00
	POLL REQUEST_ENABLE, TX_READY
	LOADR SRC1_OCR_B, INT_M1_M2|ID|BAR_SHIFT_DELAY
	POLL REQUEST_ENABLE, TX_READY
	LOADR GREEN_UPDATE_MASK, 0xFF
	POLL REQUEST_ENABLE, TX_READY
	LOADR RED_UPDATE_MASK, 0xFF
	POLL REQUEST_ENABLE, TX_READY
	LOADR BLUE_UPDATE_MASK, 0xFF
	GETVD

; added qdss template routines for x11 server
; written by matt, 17 june 1987: added full-depth tiling of rectangles
;
; USAGE
;	same as qzss.ta.  loading requires a loading routine that loads the old
;	template code, twiddles the length, and appends this code.
;	See tlLoadTemplate.c: LoadTemplate

; NOT USED!
; tlFullTile()
; Use a full-depth tile to tile a list of rectangles.
; 	tilex, tiley, tilemagic (W + H<<4)
;	{dstx, dsty, dstw, dsth}*
;
INITFILLTILERECT:
    ; init adder registers
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
	POLL REQUEST_ENABLE, TX_READY	; XXX - R_E necessary?
	LOADR SRC2_OCR_B, EXT_NONE|INT_SOURCE|NO_ID|BAR_SHIFT_DELAY
	FETCHD SOURCE_2_X, 3
FILLTILERECT:
	POLL REQUEST_ENABLE,RASTEROP_COMPLETE
	FETCHD DESTINATION_X, 3
	FETCHD SLOW_DEST_DY
	LOADD COMMAND,DTE|S2E|OCRB|LF_R3|RASTEROP
	JMPT FILLTILERECT

; RoTile()
;	bitblt same size to many places; different dests, clip areas.
;	some code stolen from bitblt.
; Bitblt DMA packet
;	srcdx, srcdy (used to determine direction)
;	srcx,srcy,dstx,dsty,dx,dy
;	{clipx1,clipx2,clipy1.clipy2}*
;
; DMA packet (RoTile)
;	srcx,srcy,dx,dy
;	clipx1,clipx2,clipy1.clipy2	(single clip rect)
;	 {dstx,dsty}*	(new dest; same size, clip)
;
INITROTILE:
    ; init adder registers
	POLL REQUEST_ENABLE,ADDRESS_COMPLETE
	POLL REQUEST_ENABLE, TX_READY
	LOADD RASTEROP_MODE,DST_WRITE_ENABLE|NORMAL	; not DST_INDEX_ENABLE
	LOADD SOURCE_1_DX, 1, 1
	FETCHD SOURCE_1_X,2
	FETCHD FAST_DEST_DX
	FETCHD SLOW_DEST_DY
	FETCHD X_CLIP_MIN,4
ROTILE:
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
	FETCHD DESTINATION_X, 2
	LOADD COMMAND,DTE|LF_R3|RASTEROP|S1E|OCRB
	JMPT ROTILE
ROTILEDONE:
	DONE

; InitSolid()
INITSOLID:
	GETVD
; Init2Tile()
INIT2TILE:
	POLL REQUEST_ENABLE, RASTEROP_COMPLETE
	FETCHD SOURCE_2_X, 3
;	POLL REQUEST_ENABLE, TX_READY
;	LOADR SRC2_OCR_B, EXT_NONE|INT_SOURCE|NO_ID|BAR_SHIFT_DELAY
	GETVD
; Init2Stipple()
INIT2STIPPLE:
	POLL REQUEST_ENABLE, RASTEROP_COMPLETE
	FETCHD SOURCE_2_X, 3
	GETVD
; Init1Tile()
INIT1TILE:
	POLL REQUEST_ENABLE, RASTEROP_COMPLETE
	FETCHD SOURCE_1_DX, 4
	LOADD RASTEROP_MODE,DST_WRITE_ENABLE|DST_INDEX_ENABLE|LINEAR_PATTERN
	GETVD
; Init1Stipple()
INIT1STIPPLE:
	POLL REQUEST_ENABLE, RASTEROP_COMPLETE
	FETCHD SOURCE_1_DX, 4
	LOADD RASTEROP_MODE,DST_WRITE_ENABLE|DST_INDEX_ENABLE|LINEAR_PATTERN
	GETVD
; TileRect()
TILERECT:
	POLL REQUEST_ENABLE,RASTEROP_COMPLETE
	FETCHD DESTINATION_X, 3
	FETCHD SLOW_DEST_DY
	LOADD COMMAND,DTE|S2E|LF_R3|OCRB|RASTEROP
	JMPT TILERECT
; TileSpan()
TILESPAN:
	POLL REQUEST_ENABLE,RASTEROP_COMPLETE
	LOADD SLOW_DEST_DY,1
TILESPANLOOP:
	POLL REQUEST_ENABLE,RASTEROP_COMPLETE
	FETCHD DESTINATION_X, 3
	LOADD COMMAND,DTE|S2E|LF_R3|OCRB|RASTEROP
	JMPT TILESPANLOOP
; SolidRect() - same as TileRect, except for that src2 is not enabled
SOLIDRECT:
	POLL REQUEST_ENABLE,RASTEROP_COMPLETE
	FETCHD DESTINATION_X, 3
	FETCHD SLOW_DEST_DY
	LOADD COMMAND,DTE|LF_R3|OCRB|RASTEROP
	JMPT SOLIDRECT
; SolidSpan() - same as TileSpan, except for that src2 is not enabled
SOLIDSPAN:
	POLL REQUEST_ENABLE,RASTEROP_COMPLETE
	LOADD SLOW_DEST_DY,1
SOLIDSPANLOOP:
	POLL REQUEST_ENABLE,RASTEROP_COMPLETE
	FETCHD DESTINATION_X, 3
	LOADD COMMAND,DTE|LF_R3|OCRB|RASTEROP
	JMPT SOLIDSPANLOOP
; PatternRect()
PATTERNRECT:
	POLL REQUEST_ENABLE,RASTEROP_COMPLETE
	LOADD FAST_SCALE,1,1
PATTERNRECTLOOP:
	POLL REQUEST_ENABLE,RASTEROP_COMPLETE
	FETCHD DESTINATION_X, 3
	FETCHD SLOW_DEST_DY
	LOADD COMMAND,DTE|S1E|LF_R3|RASTEROP
	JMPT PATTERNRECTLOOP
; PatternSpan()
PATTERNSPAN:
	POLL REQUEST_ENABLE,RASTEROP_COMPLETE
	LOADD SLOW_DEST_DY,1
	LOADD FAST_SCALE,1,1
PATTERNSPANLOOP:
	POLL REQUEST_ENABLE,RASTEROP_COMPLETE
	FETCHD DESTINATION_X, 3
	LOADD COMMAND,DTE|S1E|LF_R3|RASTEROP
	JMPT PATTERNSPANLOOP

SETALU:
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
	POLL REQUEST_ENABLE, TX_READY
	FETCHR LU_FUNCTION_R3
	GETVD

SETMASK:
	POLL REQUEST_ENABLE, TX_READY
	FETCHR MASK_1
	GETVD

; DMA packet
;	fore.r, fore.g, fore.b

SETRGBFORECOLOR:
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
    ZBLOCK ZBLOCK_RED
	POLL REQUEST_ENABLE, TX_READY
	FETCHR FOREGROUND_COLOR_Z	; foreground red
    ZBLOCK ZBLOCK_GREEN
	POLL REQUEST_ENABLE, TX_READY
	FETCHR FOREGROUND_COLOR_Z	; foreground green
    ZBLOCK ZBLOCK_BLUE
	POLL REQUEST_ENABLE, TX_READY
	FETCHR FOREGROUND_COLOR_Z	; foreground blue
	GETVD
    ZBLOCK 0

; DMA packet
;	back.r, back.g, back.b

SETRGBBACKCOLOR:
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
    ZBLOCK ZBLOCK_RED
	POLL REQUEST_ENABLE, TX_READY
	FETCHR BACKGROUND_COLOR_Z	; background red
    ZBLOCK ZBLOCK_GREEN
	POLL REQUEST_ENABLE, TX_READY
	FETCHR BACKGROUND_COLOR_Z	; background green
    ZBLOCK ZBLOCK_BLUE
	POLL REQUEST_ENABLE, TX_READY
	FETCHR BACKGROUND_COLOR_Z	; background blue
	GETVD
    ZBLOCK 0

; no packet data.
SETSRC1OCRA:
	POLL REQUEST_ENABLE, TX_READY
	FETCHR SRC1_OCR_A
	GETVD
SETSRC2OCRA:
	POLL REQUEST_ENABLE, TX_READY
	FETCHR SRC2_OCR_A
	GETVD
SETDSTOCRA:
	POLL REQUEST_ENABLE, TX_READY
	FETCHR DST_OCR_A
	GETVD
SETSRC1OCRB:
	POLL REQUEST_ENABLE, TX_READY
	FETCHR SRC1_OCR_B
	GETVD
SETSRC2OCRB:
	POLL REQUEST_ENABLE, TX_READY
	FETCHR SRC2_OCR_B
	GETVD
SETDSTOCRB:
	POLL REQUEST_ENABLE, TX_READY
	FETCHR DST_OCR_B
	GETVD

SETRASTERMODE:
	POLL REQUEST_ENABLE, RASTEROP_COMPLETE
	FETCHD RASTEROP_MODE
	GETVD

RESETRASTERMODE:
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
	LOADD RASTEROP_MODE, DST_WRITE_ENABLE | DST_INDEX_ENABLE | NORMAL
	GETVD

INITRAWPTOB:
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
	; n.b.:  rasterop mode must already have been set up.
RAWPTOB:
	FETCHD DESTINATION_X,3	; x, y, width
	FETCHD SLOW_DEST_DY	; height
	FETCHD COMMAND
	POLL REQUEST_ENABLE, TX_READY
	DONE

INITRAWBTOP:
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
	LOADD SOURCE_1_DX,1,1	; same sign as width and height
	; n.b.:  rasterop mode must already have been set up.
RAWBTOP:
	FETCHD SOURCE_1_X,2	; x, y
	FETCHD FAST_DEST_DX	; width
	FETCHD SLOW_DEST_DY	; height
	FETCHD COMMAND
	POLL REQUEST_ENABLE, RX_READY
	DONE

; BitbltNoClip()
; DMA packet
;	srcdx, srcdy (used to determine direction)
;	{srcx,srcy,dstx,dsty,dx,dy}*
;
INITBITBLTNOCLIP:
    ; init adder registers
	POLL REQUEST_ENABLE,ADDRESS_COMPLETE
	POLL REQUEST_ENABLE, TX_READY
	LOADD X_CLIP_MIN,0,1024,0,2048
	FETCHD SOURCE_1_DX,2
BITBLTNOCLIP:
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
	FETCHD SOURCE_1_X,5
	FETCHD SLOW_DEST_DY
	LOADD COMMAND,DTE|LF_R3|RASTEROP|S1E
	JMPT BITBLTNOCLIP
BITBLTDONENOCLIP:
	DONE

; InitTileBitmap
;	src2x, src2y,src2magic,{srcx,srcy,dstx,dsty,dx,dy}*
; INITTILEBITMAP is NOT USED, though TILEBITMAP is!

INITTILEBITMAP:
	POLL REQUEST_ENABLE, RASTEROP_COMPLETE
	FETCHD SOURCE_2_X, 3
	POLL REQUEST_ENABLE, TX_READY
	LOADR SRC2_OCR_B, INT_SOURCE|NO_ID|BAR_SHIFT_DELAY
TILEBITMAP:
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
	FETCHD SOURCE_1_X,5
	FETCHD SLOW_DEST_DY
	LOADD COMMAND, DTE|S1E|S2E|OCRB|LF_R3|RASTEROP
	JMPT TILEBITMAP

RESET_FAST_DY_SLOW_DX:
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
	LOADD FAST_DEST_DY,0,0
	GETVD

RESET_FORE_BACK:
	POLL REQUEST_ENABLE, TX_READY
        LOADR FOREGROUND_COLOR, 0xFFFF
	POLL REQUEST_ENABLE, TX_READY
        LOADR BACKGROUND_COLOR, 0
	GETVD


SET_MASKED_ALU:
;	Assume Planemask selects all planes
;       sets LF_R3 for given planes, to no-op for other planes
;	planemask, alu
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
        POLL REQUEST_ENABLE, TX_READY
        LOADR LU_FUNCTION_R3, 0xc | FULL_SRC_RESOLUTION ; 0xc = LF_DEST
        POLL REQUEST_ENABLE, TX_READY
        FETCHR GREEN_UPDATE_MASK
        POLL REQUEST_ENABLE, TX_READY
	FETCHR LU_FUNCTION_R3
	POLL REQUEST_ENABLE, TX_READY
	LOADR CS_UPDATE_MASK, 0xff
	GETVD

INITGET:
; Use to initialize BTP
; takes x, width (witice)
	POLL REQUEST_ENABLE, ADDRESS_COMPLETE
	LOADD DESTINATION_X, 0 ; align barrel shifter for XY mode
	FETCHD SOURCE_1_X, 1
	FETCHD SOURCE_1_DX, 1
	FETCHD FAST_DEST_DX, 1
	GETVD
