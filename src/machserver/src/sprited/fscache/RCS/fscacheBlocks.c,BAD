head     1.3;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


1.3
date     92.01.21.15.10.55;  author kupfer;  state Exp;
branches ;
next     1.2;

1.2
date     91.12.01.21.58.24;  author kupfer;  state Exp;
branches ;
next     1.1;

1.1
date     91.11.17.18.54.04;  author kupfer;  state Exp;
branches ;
next     ;


desc
@@


1.3
log
@Add "name" argument for Sync_ConditionInit calls.
@
text
@/* 
 * fscacheBlocks.c --
 *
 *	Routines to manage the <file-id, block #> cache.
 *
 * Copyright 1987 Regents of the University of California.
 * All rights reserved.
 * Permission to use, copy, modify, and distribute this
 * software and its documentation for any purpose and without
 * fee is hereby granted, provided that the above copyright
 * notice appear in all copies.  The University of California
 * makes no representations about the suitability of this
 * software for any purpose.  It is provided "as is" without
 * express or implied warranty.
 */

#ifndef lint
static char rcsid[] = "$Header: /r3/kupfer/spriteserver/src/sprited/fscache/RCS/fscacheBlocks.c,v 1.2 91/12/01 21:58:24 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
#endif not lint

#include	<sprite.h>
#include	<ckalloc.h>
#include	<fs.h>
#include	<fsutil.h>
#include	<fscache.h>
#include	<fscacheBlocks.h>
#include	<fsStat.h>
#include	<fsNameOps.h>
#include	<fsdm.h>
#include	<fsio.h>
#include	<fsutilTrace.h>
#include	<hash.h>
#include	<vm.h>
#include	<proc.h>
#include	<sys.h>
#include	<rpc.h>


/*
 * There are numerous points of synchronization in this module.  The CacheInfo
 * struct in the handle, the block info struct and several global conditions
 * and variables are used.
 *
 *     1) Synchronization between a block being fetched and a block having
 *	  good data in it.  The FSCACHE_IO_IN_PROGRESS flag is used for this.
 *	  If this flag is set in the call to Fscache_FetchBlock then the fetch
 *	  will block until the block becomes unreferenced.  Thus if the block
 *	  is already being used the user won't get their data stomped on.
 *        Whenever Fscache_FetchBlock returns a block it sets the 
 *	  FSCACHE_IO_IN_PROGRESS flag in the block.  This flag will be cleared
 *	  whenever the block is released with Fscache_UnlockBlock or the
 *	  function Fscache_IODone is called.  While this flag is set in the
 *	  block all future fetches will block until the flag is cleared.
 *
 *     2) Synchronization for changing where a block lives on disk.  When a
 *	  block cleaner is writing out a block and Fscache_UnlockBlock is
 *	  called with a new location for the block, it blocks until the
 *	  block cleaner finishes.  The flag FSCACHE_BLOCK_BEING_WRITTEN in the
 *	  cache block struct indicates this.
 *
 *     3) Waiting for blocks from a file to be written back.  This is done by
 *	  waiting for the dirty list for the file to go empty.
 *
 *     4) Waiting for blocks from the whole cache to be written back.  We
 *	  keep track of the number of cache backends starts and wake the
 *	  waiting process when this number goes to zero.
 *
 *     5) Synchronizing informing the server when there are no longer any
 *	  dirty blocks in the cache for a file.  When the last dirty block
 *	  for a file is written the write is tagged saying that it is the
 *	  last dirty block.  However the server is also told when a file is
 *	  closed if no dirty blocks are left.  Since all writes out of the
 *	  cache are unsynchronized there is a race between the close and the
 *	  delayed write back.  This is solved by using the following 
 *	  synchronization.  When a file is closed the function 
 *	  Fscache_PreventWriteBacks is called.  This function will not return
 *	  until there are no block cleaners active on the file.  When it
 *	  returns it sets the FSCACHE_CLOSE_IN_PROGRESS flag in the cacheInfo
 *	  struct in the file handle and it returns the number of dirty blocks.
 *	  All subsequent block writes are blocked until the function
 *	  Fscache_AllowWriteBacks is called.  Thus the number of dirty blocks
 *	  in the cache for the file is accurate on close because no dirty
 *	  blocks can be written out while the file is being closed.
 *	  Likewise when a block cleaner writes out the last dirty block for
 *	  a file and it tells the server on the write that its the last
 *	  dirty block the server knows that it can believe the block cleaner
 *	  if the file is closed.  This is because if its closed then it must
 *	  have been closed when the  block cleaner did the write
 *	  (all closes are prohibited during the write) and thus there
 *	  is no way that more dirty blocks can be put into the cache.
 *	  If its open then the server ignores what the block cleaner
 *	  says because it will get told again when the file is closed.
 */

/*
 * Monitor lock.
 */
static Sync_Lock	cacheLock = Sync_LockInitStatic("Fs:blockCacheLock");
#define	LOCKPTR	&cacheLock

/*
 * Condition variables.
 */
Sync_Condition	cleanBlockCondition;	/* Condition that block 
						 * allocator waits on when all 
						 * blocks are dirty. */
Sync_Condition	writeBackComplete; 	/* Condition to wait on when 
						 * are waiting for the write 
						 * back of blocks in the cache 
						 * to complete. */
Sync_Condition	closeCondition;		/* Condition to wait on when
						 * are waiting for the block
						 * cleaner to finish to write
						 * out blocks for this file. */
static unsigned int filewriteBackTime;		/* Write back all blocks in
						 * the cache file 
						 * descriptors that were
						 * dirtied before this 
						 * time. */
static int	numBackendsActive;		/* Number of backend write back
					         * processes currently active.
				                 */
/*
 * Pointer to LRU list that is used for block allocation.
 */
static	List_Links	lruListHdr;
#define	lruList		(&lruListHdr)

/*
 * There are two free lists.  The first contains blocks that are in pages that
 * only contain free blocks.  The second contains blocks that are in pages that
 * contain non-free blocks.  When the physical pages size <= the block size then
 * the second list will always be empty.
 */
static	List_Links	totFreeListHdr;
#define	totFreeList	(&totFreeListHdr)
static	List_Links	partFreeListHdr;
#define	partFreeList	(&partFreeListHdr)

/*
 * Pointer to list of unmapped blocks.
 */
static	List_Links	unmappedListHdr;
#define	unmappedList	(&unmappedListHdr)

/*
 * List of Fscache_Backend's that could have file in the cache.
 * This list is kept so CacheWriteBack has a list of all the
 * backends that could have files in the cache. 
 */
static	List_Links	backendListHdr;
#define	backendList 	(&backendListHdr)

/*
 * Writes and reads can block on a full cache.  This list records the
 * processes that are blocked on this condition.
 */
List_Links fscacheFullWaitListHdr;
List_Links *fscacheFullWaitList = &fscacheFullWaitListHdr;

/*
 * Hash tables for blocks.
 */
static	Hash_Table	blockHashTableStruct;
static	Hash_Table	*blockHashTable = &blockHashTableStruct;

/*
 * The key to use for the block hash and a macro to set it.  The fact
 * that the key includes a pointer into the I/O handle for the block
 * means that this handle has to be kept around until there are no
 * blocks left in the cache.
 */
typedef	struct {
    Fscache_FileInfo *cacheInfoPtr;
    int		blockNumber;
} BlockHashKey;
#define	SET_BLOCK_HASH_KEY(blockHashKey, ZcacheInfoPtr, fileBlock) \
    (blockHashKey).cacheInfoPtr = ZcacheInfoPtr; \
    (blockHashKey).blockNumber = fileBlock;

/*
 * Miscellaneous variables.
 */
static	Address	blockCacheStart;	/* The address of the beginning of the
				   	   block cache. */
static	Address	blockCacheEnd;		/* The maximum virtual address for the 
					 * cache.*/
static	int	pageSize;		/* The size of a physical page. */
static	int	blocksPerPage;		/* Number of blocks in a page. */

static  int	numAvailBlocks;		/* Number of cache block available for 
					 * use without waiting. */
static  int	minNumAvailBlocks;	/* Minimum number of cache blocks to
					 * keep available. */

/*
 * Macros for large page sizes.
 *
 *	GET_OTHER_BLOCK		Return a pointer to the other block in
 *				the page given a pointer to one of the blocks.
 *	PAGE_IS_8K		Return true if the VM page size is 8K.
 */
#define GET_OTHER_BLOCK(blockPtr) \
    (((int) blockPtr->blockAddr & (pageSize - 1)) != 0) ?  \
		blockPtr - 1 : blockPtr + 1

#define	PAGE_IS_8K	(pageSize == 8192)

/*
 * External symbols.
 */

int	fscache_MaxBlockCleaners = FSCACHE_MAX_CLEANER_PROCS;

/*
 * Internal functions.
 */
static void CacheFileInvalidate _ARGS_((Fscache_FileInfo *cacheInfoPtr, 
			int firstBlock, int lastBlock));
static void DeleteBlockFromDirtyList _ARGS_((Fscache_Block *blockPtr));
static void StartFileSync _ARGS_((Fscache_FileInfo *cacheInfoPtr));
static void CacheWriteBack _ARGS_((unsigned int writeBackTime, 
			int *blocksSkippedPtr));
static Boolean CreateBlock _ARGS_((Boolean retBlock,
			Fscache_Block **blockPtrPtr));
static Boolean DestroyBlock _ARGS_((Boolean retOnePage, int *pageNumPtr));
#ifdef SOSP91
static Fscache_Block *FetchBlock _ARGS_((Boolean canWait, Boolean cantBlock,
			unsigned int flags));
#else
static Fscache_Block *FetchBlock _ARGS_((Boolean canWait, Boolean cantBlock));
#endif /* SOSP91 */
static void StartBackendWriteback _ARGS_((Fscache_Backend *backendPtr));
static void PutOnFreeList _ARGS_((Fscache_Block *blockPtr));
static void PutFileOnDirtyList _ARGS_((Fscache_FileInfo *cacheInfoPtr,
			time_t oldestDirtyBlockTime));
static void PutBlockOnDirtyList _ARGS_((Fscache_Block *blockPtr, 
			Boolean onFront));
static Hash_Entry *GetUnlockedBlock _ARGS_((BlockHashKey *blockHashKeyPtr, 
			int blockNum));
static void DeleteBlock _ARGS_((Fscache_Block *blockPtr));


/*
 * ----------------------------------------------------------------------------
 *
 * Fscache_Init --
 *
 * 	Initialize the cache.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Hash tables initialized and memory allocated for the cache.
 *
 * ----------------------------------------------------------------------------
 */
void
Fscache_Init(blockHashSize)
    int	blockHashSize;	/* The number of hash table entries to put in the
			   block hash table for starters. */
{
    register	Address		blockAddr;
    Address			listStart;
    register	Fscache_Block	*blockPtr;
    register	int		i;

    Vm_FsCacheSize(&blockCacheStart, &blockCacheEnd);
    pageSize = Vm_GetPageSize();
    blocksPerPage = pageSize / FS_BLOCK_SIZE;
    /*
     * Currently the cache code only handles the case for 
     * (pageSize != FS_BLOCK_SIZE) when the block size is 4K and 
     * the page size 8K.  If this code is ever made more general, be sure
     * to verify the correctness of the code in vmFsCache.c.
     */
    if (!((pageSize == FS_BLOCK_SIZE) ||
	  ((FS_BLOCK_SIZE == 4096) && PAGE_IS_8K))) {
	panic("Bad pagesize (%d) for file cache code\n", pageSize);
    }
    fs_Stats.blockCache.maxNumBlocks = 
			(blockCacheEnd - blockCacheStart + 1) / FS_BLOCK_SIZE;

    fs_Stats.blockCache.minCacheBlocks = FSCACHE_MIN_BLOCKS;
    fs_Stats.blockCache.maxCacheBlocks = fs_Stats.blockCache.maxNumBlocks;

    /*
     * Allocate space for the cache block list.
     */
    listStart = Vm_RawAlloc((int)fs_Stats.blockCache.maxNumBlocks *
			    sizeof(Fscache_Block));
    blockPtr = (Fscache_Block *) listStart;

    /*
     * Initialize the hash table.
     */
    Hash_Init(blockHashTable, blockHashSize, Hash_Size(sizeof(BlockHashKey)));

    /*
     * Initialize all lists.
     */
    List_Init(lruList);
    List_Init(totFreeList);
    List_Init(partFreeList);
    List_Init(backendList);
    List_Init(unmappedList);
    List_Init(fscacheFullWaitList);

    for (i = 0, blockAddr = blockCacheStart, 
		blockPtr = (Fscache_Block *)listStart;
	 i < fs_Stats.blockCache.maxNumBlocks; 
	 i++, blockPtr++, blockAddr += FS_BLOCK_SIZE) {
	blockPtr->flags = FSCACHE_NOT_MAPPED;
	blockPtr->blockAddr = blockAddr;
	blockPtr->refCount = 0;
	Sync_ConditionInit(&blockPtr->ioDone, "fscache:ioDone", TRUE);
	List_Insert(&blockPtr->useLinks, LIST_ATREAR(unmappedList));
    }
    /*
     * Give enough blocks memory so that the minimum cache size requirement
     * is met.
     */
    fs_Stats.blockCache.numCacheBlocks = 0;
    while (fs_Stats.blockCache.numCacheBlocks < 
					fs_Stats.blockCache.minCacheBlocks) {
	if (!CreateBlock(FALSE, (Fscache_Block **) NIL)) {
	    printf("Fscacahe_Init: Couldn't create block\n");
	    fs_Stats.blockCache.minCacheBlocks = 
					fs_Stats.blockCache.numCacheBlocks;
	}
    }
    minNumAvailBlocks = fs_Stats.blockCache.minCacheBlocks/2;
    printf("FS Cache has %d %d-Kbyte blocks (%d max)\n",
	    fs_Stats.blockCache.minCacheBlocks, FS_BLOCK_SIZE / 1024,
	    fs_Stats.blockCache.maxNumBlocks);

}


/*
 * ----------------------------------------------------------------------------
 *
 * Fscache_FileInfoInit --
 *
 * 	Initialize the cache information for a file.  Called when setting
 *	up a handle for a file that uses the block cache.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Set up the fields of the Fscache_FileInfo struct. First file may
 *	cause the backend to be initialized.
 *	
 * ----------------------------------------------------------------------------
 */
void
Fscache_FileInfoInit(cacheInfoPtr, hdrPtr, version, cacheable, attrPtr, 
		backendPtr)
    register Fscache_FileInfo *cacheInfoPtr;	/* Information to initialize. */
    Fs_HandleHeader	     *hdrPtr;		/* Back pointer to handle */
    int			     version;		/* Used to check consistency */
    Boolean		     cacheable;		/* TRUE if server says we can
						 * cache */
    Fscache_Attributes	     *attrPtr;		/* File attributes */
    Fscache_Backend	     *backendPtr;	/* Cache backend for
						 * this file. */
{
    List_InitElement(&cacheInfoPtr->links);
    List_Init(&cacheInfoPtr->dirtyList);
    List_Init(&cacheInfoPtr->blockList);
    List_Init(&cacheInfoPtr->indList);
    cacheInfoPtr->flags = (cacheable ? 0 : FSCACHE_FILE_NOT_CACHEABLE);
    cacheInfoPtr->version = version;
    cacheInfoPtr->hdrPtr = hdrPtr;
    cacheInfoPtr->blocksWritten = 0;
    Sync_ConditionInit(&cacheInfoPtr->noDirtyBlocks,
		       "fscache:noDirtyBlocks", TRUE);
    cacheInfoPtr->blocksInCache = 0;
    cacheInfoPtr->numDirtyBlocks = 0;
    cacheInfoPtr->lastTimeTried = 0;
    cacheInfoPtr->oldestDirtyBlockTime = Fsutil_TimeInSeconds();
    cacheInfoPtr->attr = *attrPtr;
    cacheInfoPtr->backendPtr = backendPtr;
    Sync_LockInitDynamic(&cacheInfoPtr->lock, "Fs:perFileCacheLock");
}

/*
 * ----------------------------------------------------------------------------
 *
 * Fscache_InfoSyncLockCleanup --
 *
 * 	Clean up Sync_Lock tracing for the cache lock.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Set up the fields of the Fscache_FileInfo struct.
 *
 * ----------------------------------------------------------------------------
 */
/*ARGSUSED*/
void
Fscache_InfoSyncLockCleanup(cacheInfoPtr)
    Fscache_FileInfo *cacheInfoPtr;
{
    Sync_LockClear(&cacheInfoPtr->lock);
}



/*
 *----------------------------------------------------------------------
 *
 * Fscache_RegisterBackend --
 *
 *	Allocate and initialize the Fscache_Backend data structure for a 
 *	cache backend.
 *
 * Results:
 *	The malloc'ed cache backend.
 *
 * Side effects:
 *	The backend is added to the backendList.
 *
 *----------------------------------------------------------------------
 */

Fscache_Backend *
Fscache_RegisterBackend(ioProcsPtr, clientData, flags)
    Fscache_BackendRoutines   *ioProcsPtr;
    ClientData	clientData;
    int	     flags;	/* Backend flags. */
{
    Fscache_Backend	*backendPtr;

    LOCK_MONITOR;

    backendPtr = (Fscache_Backend *) ckalloc(sizeof(Fscache_Backend));
    bzero((char *) backendPtr, sizeof(Fscache_Backend));

    List_Init((List_Links *)backendPtr);
    backendPtr->clientData = clientData;
    backendPtr->flags = flags;
    List_Init((List_Links *)&(backendPtr->dirtyListHdr));
    backendPtr->ioProcs = *ioProcsPtr;

    List_Insert((List_Links *)backendPtr, LIST_ATREAR(backendList));
    UNLOCK_MONITOR;
    return backendPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * Fscache_UnregisterBackend --
 *
 *	Deallocate a Fscache_Backend data structure allocated with
 *	Fscache_RegisterBackend.
 *
 * Results:
 *
 * Side effects:
 *	Backend is removed from the list of active backends and its memory
 *	is freed.
 *
 *----------------------------------------------------------------------
 */

void
Fscache_UnregisterBackend(backendPtr)
    Fscache_Backend	*backendPtr; /* Backend to deallocate. */
{

    LOCK_MONITOR;

    if (!List_IsEmpty(&(backendPtr->dirtyListHdr))) {
	UNLOCK_MONITOR;
	panic("Fscache_UnregisterBackend: Backend has dirty files.\n");
	return;
    }
    List_Remove((List_Links *)backendPtr);
    /*
     * Until we get a better grip on the file handle code we can't free
     * the backendPtr because the cacheInfoPtr in the handle may still
     * point at it.  
     *
     * THIS IS A MEMORY LEAK - 48 bytes per backend unregistered. 
     * Currently this only happens when an LFS file system is 
     * unattached.
     */

#ifdef notdef
#ifndef CLEAN
    /*
     * NIL out these fields in hope in catching any bad code that
     * trys to use them.
     */
    backendPtr->clientData = (ClientData) NIL;
    backendPtr->ioProcs.allocate = (ReturnStatus (*)()) NIL;
    backendPtr->ioProcs.blockRead = (ReturnStatus (*)()) NIL;
    backendPtr->ioProcs.blockWrite = (ReturnStatus (*)()) NIL;
    backendPtr->ioProcs.reallocBlock = (void (*)()) NIL;
    backendPtr->ioProcs.startWriteBack = (ReturnStatus (*)()) NIL;
#endif /* not CLEAN */

    ckfree((char *) backendPtr);
#endif /* notdef */

    UNLOCK_MONITOR;
    return;
}



/*
 * ----------------------------------------------------------------------------
 *
 *	Functions for external block access.  Includes functions to fetch,
 *	release and truncate cache blocks.
 *
 * ----------------------------------------------------------------------------
 */

/*
 * ----------------------------------------------------------------------------
 *
 * Fscache_FetchBlock --
 *
 *	Return in *blockPtrPtr a pointer to a block in the 
 *	cache that corresponds to virtual block blockNum in the file 
 *	identified by *cacheInfoPtr.  If the block for the file is not in the 
 *	cache then *foundPtr is set to FALSE and if allocate is 
 *	TRUE, then a clean block is returned.  Otherwise a pointer to the 
 *	actual data block is returned and *foundPtr is set to TRUE.
 *	The block that is returned is locked down in the cache (i.e. it cannot
 *	be replaced) until it is unlocked by Fscache_UnlockBlock.  If the block
 *	isn't found or the FSCACHE_IO_IN_PROGRESS flag is given then the block
 *	is marked as IO in progress and must be either unlocked by 
 *	Fscache_UnlockBlock or marked as IO done by Fscache_IODone.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	New block may be allocated out of the block cache, block that 
 *	is returned is locked, and the block may be set as IO in progress.
 *
 * ----------------------------------------------------------------------------
 *
 */
static Fscache_Block *lostBlockPtr;

ENTRY void
Fscache_FetchBlock(cacheInfoPtr, blockNum, flags, blockPtrPtr, foundPtr)
    register Fscache_FileInfo *cacheInfoPtr; /* Pointer to the cache state 
				   * for the file. */
    int		 blockNum;	/* Virtual block number in the file. */
    int		 flags;		/* FSCACHE_DONT_BLOCK |
				 * FSCACHE_CANT_BLOCK |
				 * FSCACHE_READ_AHEAD_BLOCK |
				 * FSCACHE_IO_IN_PROGRESS
				 * plus the type of block */
    Fscache_Block **blockPtrPtr; /* Where pointer to cache block information
				 * structure is returned. The structure
				 * contains the virtual address of the 
				 * actual cache block. */
    Boolean	*foundPtr;	/* TRUE if the block is present in the
				 * cache, FALSE if not. */
{
    BlockHashKey		blockHashKey;
    register	Hash_Entry	*hashEntryPtr;
    register	Fscache_Block	*blockPtr;
    Fscache_Block		*otherBlockPtr;
    Fscache_Block		*newBlockPtr;
    time_t			refTime;
    Boolean		cantBlock = (flags & FSCACHE_CANT_BLOCK);
    Boolean		dontBlock = (flags & FSCACHE_DONT_BLOCK);

    LOCK_MONITOR;

    *blockPtrPtr = (Fscache_Block *)NIL;
    SET_BLOCK_HASH_KEY(blockHashKey, cacheInfoPtr, blockNum);

    do {
	/*
	 * Keep re-hashing until we get a block.  If we ever have to
	 * wait in this loop then the hash table can change out from
	 * under us, so we always rehash.
	 */
	hashEntryPtr = Hash_Find(blockHashTable, (Address) &blockHashKey);
	blockPtr = (Fscache_Block *) Hash_GetValue(hashEntryPtr);
	if (blockPtr != (Fscache_Block *) NIL) {
	    Boolean	blockBusy;
	    *foundPtr = TRUE;
	    if (blockPtr->fileNum != cacheInfoPtr->hdrPtr->fileID.minor) {
		UNLOCK_MONITOR;
		panic("Fscache_FetchBlock hashing error\n");
		*foundPtr = FALSE;
		return;
	    }
	    blockBusy = ((blockPtr->refCount > 0) || 
		    (blockPtr->flags & (FSCACHE_IO_IN_PROGRESS|
					FSCACHE_BLOCK_BEING_WRITTEN)));
	    if ( ((flags & FSCACHE_IO_IN_PROGRESS) && blockBusy) ||
		  (blockPtr->flags & FSCACHE_IO_IN_PROGRESS)) {
		if (!dontBlock) {
		    /*
		     * Wait until it becomes unlocked, or return
		     * found = TRUE and block = NIL if caller can't block.
		     */
		    (void)Sync_Wait(&blockPtr->ioDone, FALSE);
		}
		blockPtr = (Fscache_Block *)NIL;
	    } else {
		blockPtr->refCount++;
		if (blockPtr->refCount == 1) {
		    if (!(blockPtr->flags & FSCACHE_BLOCK_DIRTY)) {
			numAvailBlocks--;
			if (numAvailBlocks < 0) {
			    panic("Fscache_FetchBlock numAvailBlocks < 0\n");
			}
		    }
		}
		if (flags & FSCACHE_IO_IN_PROGRESS) {
		    blockPtr->flags |= FSCACHE_IO_IN_PROGRESS;
		}
	    }
	} else {
	    /*
	     * Have to allocate a block.  If there is a free block use it, or
	     * take a block off of the lru list, or make a new one.
	     */
	    *foundPtr = FALSE;
	    if ((numAvailBlocks > minNumAvailBlocks) || cantBlock) {
		/*
		 * If we have enought blocks available take a free one.
		 */
		if (!List_IsEmpty(partFreeList)) {
		    /*
		     * Use partially free blocks first.
		     */
		    fs_Stats.blockCache.numFreeBlocks--;
		    fs_Stats.blockCache.partFree++;
		    blockPtr = USE_LINKS_TO_BLOCK(List_First(partFreeList));
		    List_Remove(&blockPtr->useLinks);
		} else if (!List_IsEmpty(totFreeList)) {
		    /*
		     * Can't find a partially free block so use a totally free
		     * block.
		     */
		    fs_Stats.blockCache.numFreeBlocks--;
		    fs_Stats.blockCache.totFree++;
		    blockPtr = USE_LINKS_TO_BLOCK(List_First(totFreeList));
		    List_Remove(&blockPtr->useLinks);
		    if (PAGE_IS_8K) {
			otherBlockPtr = GET_OTHER_BLOCK(blockPtr);
			List_Move(&otherBlockPtr->useLinks,
				      LIST_ATREAR(partFreeList));
		    }
		}
	    }
	    if (blockPtr == (Fscache_Block *) NIL) {
		/*
		 * Can't find any free blocks so have to use one of our blocks
		 * or create new ones.
		 */
		if (fs_Stats.blockCache.numCacheBlocks >= 
				    fs_Stats.blockCache.maxCacheBlocks) {
		    /*
		     * We can't have anymore blocks so reuse one of our own.
		     */
#ifdef SOSP91
		    blockPtr = FetchBlock(!dontBlock, cantBlock,
			    FSCACHE_BLOCK_LRU);
#else
		    blockPtr = FetchBlock(!dontBlock, cantBlock);
#endif /* SOSP91 */
		    if ((blockPtr == (Fscache_Block *) NIL) && cantBlock) {
			goto getBlock;
		    }
		} else {
		    /*
		     * Grow the cache if VM has an older page than we have.
		     */
		    refTime = Vm_GetRefTime();
		    blockPtr = USE_LINKS_TO_BLOCK(List_First(lruList));
		    if (blockPtr->timeReferenced > refTime) {
		getBlock:
			if (!CreateBlock(TRUE, &newBlockPtr)) {
#ifdef SOSP91
			    blockPtr = FetchBlock(!dontBlock, cantBlock,
				    FSCACHE_BLOCK_LRU);
#else
			    blockPtr = FetchBlock(!dontBlock, cantBlock);
#endif /* SOSP91 */
			} else {
			    fs_Stats.blockCache.unmapped++;
			    blockPtr = newBlockPtr;
			}
		    } else {
			/*
			 * We have an older block than VM's oldest page so reuse
			 * the block.
			 */
#ifdef SOSP91
			blockPtr = FetchBlock(!dontBlock, cantBlock,
				FSCACHE_BLOCK_LRU);
#else
			blockPtr = FetchBlock(!dontBlock, cantBlock);
#endif /* SOSP91 */
		    }
		}
	    }
	    /*
	     * If blockPtr is NIL we waited for room in the cache or
	     * for a busy cache block.  Now we'll retry all the various
	     * ploys to get a free block.
	     */
	}
    } while ((blockPtr == (Fscache_Block *)NIL) && !dontBlock);

    if ((*foundPtr == FALSE) && (blockPtr != (Fscache_Block *)NIL)) {
	cacheInfoPtr->blocksInCache++;
	blockPtr->cacheInfoPtr = cacheInfoPtr;
	blockPtr->refCount = 1;
	blockPtr->flags = flags & (FSCACHE_DATA_BLOCK | FSCACHE_IND_BLOCK |
				   FSCACHE_DESC_BLOCK | FSCACHE_DIR_BLOCK |
				   FSCACHE_READ_AHEAD_BLOCK);
	blockPtr->flags |= FSCACHE_IO_IN_PROGRESS;
	blockPtr->fileNum = cacheInfoPtr->hdrPtr->fileID.minor;
	blockPtr->blockNum = blockNum;
	blockPtr->blockSize = -1;
	blockPtr->timeDirtied = 0;
	blockPtr->timeReferenced = Fsutil_TimeInSeconds();
	*blockPtrPtr = blockPtr;
	if (Hash_GetValue(hashEntryPtr) != (char *)NIL) {
	    lostBlockPtr = (Fscache_Block *)Hash_GetValue(hashEntryPtr);
	    UNLOCK_MONITOR;
	    panic("Fscache_FetchBlock: hashEntryPtr->value changed\n");
	    LOCK_MONITOR;
	}
	Hash_SetValue(hashEntryPtr, blockPtr);
	List_Insert(&(blockPtr->useLinks), LIST_ATREAR(lruList));
	List_InitElement(&blockPtr->fileLinks);
	if (flags & FSCACHE_IND_BLOCK) {
	    List_Insert(&blockPtr->fileLinks, LIST_ATREAR(&cacheInfoPtr->indList));
	} else {
	    List_Insert(&blockPtr->fileLinks,LIST_ATREAR(&cacheInfoPtr->blockList));
	}
	numAvailBlocks--;
	if (numAvailBlocks < 0) {
	    panic("Fscache_FetchBlock numAvailBlocks < 0.\n");
	}
    }
    *blockPtrPtr = blockPtr;
    UNLOCK_MONITOR;
    return;
}


/*
 * ----------------------------------------------------------------------------
 *
 * Fscache_IODone --
 *
 *	Remove the IO-in-progress flag from the cache block flags field.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The IO-in-progress flag is removed from the cache block flags field.
 *
 * ----------------------------------------------------------------------------
 *
 */
ENTRY void
Fscache_IODone(blockPtr)
    Fscache_Block *blockPtr;	/* Pointer to block information for block.*/
{
    LOCK_MONITOR;

    Sync_Broadcast(&blockPtr->ioDone);
    blockPtr->flags &= ~FSCACHE_IO_IN_PROGRESS;

    UNLOCK_MONITOR;
}

/*
 * ----------------------------------------------------------------------------
 *
 * Fscache_UnlockBlock --
 *
 *	Release the lock on the cache block pointed to by blockPtr.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The lock count of the block is decremented.
 *
 * ----------------------------------------------------------------------------
 *
 */
ENTRY void
Fscache_UnlockBlock(blockPtr, timeDirtied, diskBlock, blockSize, flags)
    Fscache_Block *blockPtr;	/* Pointer to block information for block
				   that is to be released. */
    time_t	 timeDirtied;	/* Time in seconds that the block was 
				   dirtied. */
    int		 diskBlock;	/* If not -1 is the block on disk where this
				   block resides.  For remote blocks this 
				   should be the same as blockPtr->blockNum.*/
    int		 blockSize;	/* The number of valid bytes in this block. */
    int		 flags;		/* FSCACHE_DELETE_BLOCK | FSCACHE_CLEAR_READ_AHEAD |
				 * FSCACHE_BLOCK_UNNEEDED | FSCACHE_DONT_WRITE_THRU
				 * FSCACHE_WRITE_TO_DISK | FSCACHE_BLOCK_BEING_CLEANED*/
{
    LOCK_MONITOR;

    if (blockPtr->flags & FSCACHE_BLOCK_FREE) {
	panic("Checking in free block\n");
    }

    if (blockPtr->flags & FSCACHE_IO_IN_PROGRESS) {
	Sync_Broadcast(&blockPtr->ioDone);
	blockPtr->flags &= ~FSCACHE_IO_IN_PROGRESS;
    }

    if (flags & FSCACHE_DELETE_BLOCK) {
	/*
	 * The caller is deleting this block from the cache.  Decrement the
	 * lock count and then invalidate the block.
	 */
	blockPtr->refCount--;
	if (blockPtr->refCount == 0) { 
	    if (!(blockPtr->flags & 
			(FSCACHE_BLOCK_DIRTY|FSCACHE_BLOCK_BEING_WRITTEN))) {
		numAvailBlocks++;
		if (! List_IsEmpty(fscacheFullWaitList)) {
		    Fsutil_WaitListNotify(fscacheFullWaitList);
		}
		Sync_Broadcast(&cleanBlockCondition);
	    }
	}
	CacheFileInvalidate(blockPtr->cacheInfoPtr, blockPtr->blockNum, 
			    blockPtr->blockNum);
	UNLOCK_MONITOR;
	return;
    }

    if (flags & FSCACHE_CLEAR_READ_AHEAD) {
	blockPtr->flags &= ~FSCACHE_READ_AHEAD_BLOCK;
    }
    if (timeDirtied != 0) {
	if (flags & FSCACHE_BLOCK_BEING_CLEANED) {
	    blockPtr->cacheInfoPtr->flags |= FSCACHE_FILE_BEING_CLEANED;
	    blockPtr->flags |= FSCACHE_BLOCK_BEING_CLEANED;
	}
	if (!(blockPtr->flags & FSCACHE_BLOCK_DIRTY)) {
	    /*
	     * Increment the count of dirty blocks if the block isn't marked
	     * as dirty.  The block cleaner will decrement the count 
	     * after it cleans a block.
	     */
	    blockPtr->flags |= FSCACHE_BLOCK_DIRTY;
	    blockPtr->timeDirtied = timeDirtied;
	    if (!(blockPtr->flags & FSCACHE_BLOCK_BEING_WRITTEN)) { 
		blockPtr->cacheInfoPtr->numDirtyBlocks++;
		PutBlockOnDirtyList(blockPtr, FALSE);
	    }
	}
    }
    if (diskBlock != -1) {
	blockPtr->diskBlock = diskBlock;
	if (blockPtr->blockSize != blockSize) {
	    blockPtr->blockSize = blockSize;
	}
    } else if (blockPtr->blockSize == -1 && blockSize > 0) {
	/*
	 * Patch up the block size so our internal fragmentation
	 * calculation is correct.  The size of a read-only block
	 * is not used for anything else.
	 */
	blockPtr->blockSize = blockSize;
    }

    blockPtr->refCount--;
    if (blockPtr->refCount == 0) {
	/*
	 * Wake up anybody waiting for the block to become unlocked.
	 */
	Sync_Broadcast(&blockPtr->ioDone);
	if (!(blockPtr->flags & 
		(FSCACHE_BLOCK_DIRTY | FSCACHE_BLOCK_BEING_WRITTEN))) {
	    numAvailBlocks++;
	    if (! List_IsEmpty(fscacheFullWaitList)) {
		Fsutil_WaitListNotify(fscacheFullWaitList);
	    }
	    Sync_Broadcast(&cleanBlockCondition);
	}
	if (blockPtr->flags & FSCACHE_BLOCK_CLEANER_WAITING) {
	    StartBackendWriteback(blockPtr->cacheInfoPtr->backendPtr);
	    blockPtr->flags &= ~FSCACHE_BLOCK_CLEANER_WAITING;
	}
	if (flags & FSCACHE_BLOCK_UNNEEDED) {
	    /*
	     * This block is unneeded so move it to the front of the LRU list
	     * and set its time referenced to zero so that it will be taken
	     * at the next convenience.
	     */
	    if (blockPtr->flags & FSCACHE_BLOCK_DIRTY) {
		blockPtr->flags |= FSCACHE_MOVE_TO_FRONT;
	    } else {
		List_Move(&blockPtr->useLinks, LIST_ATFRONT(lruList));
	    }
	    fs_Stats.blockCache.blocksPitched++;
	    blockPtr->timeReferenced = 0;
	} else {
	    /*
	     * Move it to the end of the lru list, mark it as being referenced. 
	     */
	    blockPtr->timeReferenced = Fsutil_TimeInSeconds();
	    blockPtr->flags &= ~FSCACHE_MOVE_TO_FRONT;
	    List_Move( &blockPtr->useLinks, LIST_ATREAR(lruList));
	}
    }

    UNLOCK_MONITOR;
}


/*
 * ----------------------------------------------------------------------------
 *
 * Fscache_BlockTrunc --
 *
 * 	Truncate the given cache block.  Used to set the blockSize in the
 *	cache block to reflect the actual amount of data in the block after
 *	a truncate.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	blockSize in block is changed.
 *
 * ----------------------------------------------------------------------------
 */
ENTRY void
Fscache_BlockTrunc(cacheInfoPtr, blockNum, newBlockSize)
    Fscache_FileInfo *cacheInfoPtr;	/* Cache state of file. */
    int		blockNum;		/* Block to truncate. */
    int		newBlockSize;		/* New block size. */
{
    register Hash_Entry	     *hashEntryPtr;
    register Fscache_Block    *blockPtr;
    BlockHashKey	     blockHashKey;

    LOCK_MONITOR;

    SET_BLOCK_HASH_KEY(blockHashKey, cacheInfoPtr, 0);

    hashEntryPtr = GetUnlockedBlock(&blockHashKey, blockNum);
    if (hashEntryPtr != (Hash_Entry *) NIL) {
	blockPtr = (Fscache_Block *) Hash_GetValue(hashEntryPtr);

	if (blockPtr->fileNum != cacheInfoPtr->hdrPtr->fileID.minor) {
	    panic( "CacheBlockTrunc, hashing error\n");
	} else {
	    blockPtr->blockSize = newBlockSize;
	}
    }

    UNLOCK_MONITOR;
}


/*
 * ----------------------------------------------------------------------------
 *
 *	Functions to perform some action on a file.  This includes write-back
 *	and invalidation.
 *
 * ----------------------------------------------------------------------------
 */

/*
 * ----------------------------------------------------------------------------
 *
 * Fscache_FileInvalidate --
 *
 * 	This function removes from the cache all blocks for the file 
 *	identified by *filePtr in the range firstBlock to lastBlock.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	All blocks in the cache for the file are removed.
 *
 * ----------------------------------------------------------------------------
 *
 */
ENTRY void
Fscache_FileInvalidate(cacheInfoPtr, firstBlock, lastBlock)
    Fscache_FileInfo *cacheInfoPtr;	/* Cache state of file to invalidate. */
    int		firstBlock;	/* First block to invalidate. Starts at zero. */
    int		lastBlock;	/* Last block to invalidate.  FSCACHE_LAST_BLOCK
				 * can be used if the caller doesn't know
				 * the exact last block of the file. */
{
    LOCK_MONITOR;

    if (lastBlock == FSCACHE_LAST_BLOCK) {
	if (cacheInfoPtr->attr.lastByte > 0) {
	    lastBlock = cacheInfoPtr->attr.lastByte / FS_BLOCK_SIZE;
	} else {
	    lastBlock = 0;
	}
    }
    CacheFileInvalidate(cacheInfoPtr, firstBlock, lastBlock);

    UNLOCK_MONITOR;
}



/*
 * ----------------------------------------------------------------------------
 *
 * CacheFileInvalidate --
 *
 * 	This function removes from the cache all blocks for the given file 
 *	identified in the range firstBlock to lastBlock.  If any blocks are 
 *	being written to disk, it will block until they have finished being
 *	written.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	All blocks in the cache for the file are removed.
 *
 * ----------------------------------------------------------------------------
 */
INTERNAL static void
CacheFileInvalidate(cacheInfoPtr, firstBlock, lastBlock)
    Fscache_FileInfo	*cacheInfoPtr;	/* File to invalidate. */
    int			firstBlock;	/* First block to invalidate. */
    int			lastBlock;	/* Last block to invalidate. */
{
    register Hash_Entry	     *hashEntryPtr;
    register Fscache_Block    *blockPtr;
    BlockHashKey	     blockHashKey;
    int			     i;


    if (cacheInfoPtr->blocksInCache > 0) {
	SET_BLOCK_HASH_KEY(blockHashKey, cacheInfoPtr, 0);

	for (i = firstBlock; i <= lastBlock; i++) {
	    hashEntryPtr = GetUnlockedBlock(&blockHashKey, i);
	    if (hashEntryPtr == (Hash_Entry *) NIL) {
		continue;
	    }
	    blockPtr = (Fscache_Block *) Hash_GetValue(hashEntryPtr);
	    if (blockPtr->fileNum != cacheInfoPtr->hdrPtr->fileID.minor) {
		panic( "CacheFileInvalidate, hashing error\n");
		continue;
	    }

	    /*
	     * Remove it from the hash table.
	     */
	    cacheInfoPtr->blocksInCache--;
	    List_Remove(&blockPtr->fileLinks);
	    Hash_Delete(blockHashTable, hashEntryPtr);

	    /*
	     * Invalidate the block, including removing it from dirty list
	     * if necessary.
	     */
	    if (blockPtr->flags & FSCACHE_BLOCK_DIRTY) {
		cacheInfoPtr->numDirtyBlocks--;
		DeleteBlockFromDirtyList(blockPtr);
		numAvailBlocks++;
	    }
	    List_Remove(&blockPtr->useLinks);
	    PutOnFreeList(blockPtr);
	}
    }
    if (cacheInfoPtr->blocksInCache == 0) {
	cacheInfoPtr->flags &=
			~(FSCACHE_SERVER_DOWN | FSCACHE_NO_DISK_SPACE |
			  FSCACHE_DOMAIN_DOWN | FSCACHE_GENERIC_ERROR);
    }
}


/*
 * ----------------------------------------------------------------------------
 *
 * DeleteBlockFromDirtyList --
 *
 * 	Delete the given block from the dirty list.  This is done when
 *	the file is being deleted.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	If this is the last dirty block of a file then the file is
 *	removed from the file dirty list.  Also, if someone was waiting
 *	on the block the global writeBackComplete is notified.
 *
 * ----------------------------------------------------------------------------
 */
INTERNAL static void
DeleteBlockFromDirtyList(blockPtr)
    register	Fscache_Block	*blockPtr;
{
    register	Fscache_FileInfo	*cacheInfoPtr;

    cacheInfoPtr = blockPtr->cacheInfoPtr;
    List_Remove(&blockPtr->dirtyLinks);
    if ((cacheInfoPtr->flags & FSCACHE_FILE_ON_DIRTY_LIST) &&
        (cacheInfoPtr->numDirtyBlocks == 0) &&
	!(cacheInfoPtr->flags & FSCACHE_FILE_DESC_DIRTY)) {
	/*
	 * No more dirty blocks for this file.  Remove the file from the dirty
	 * list and wakeup anyone waiting for the file's list to become
	 * empty.
	 */
	List_Remove((List_Links *)cacheInfoPtr);
	cacheInfoPtr->flags &= ~(FSCACHE_FILE_ON_DIRTY_LIST|FSCACHE_FILE_FSYNC|FSCACHE_FILE_BEING_CLEANED);
	Sync_Broadcast(&cacheInfoPtr->noDirtyBlocks);
    }

}

/*
 *----------------------------------------------------------------------
 *
 * StartFileSync --
 *
 *	Start the process of syncing from the cache to the backend.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Backend may be started. File may be moved up the dirty list.
 *
 *----------------------------------------------------------------------
 */
static void
StartFileSync(cacheInfoPtr)
    Fscache_FileInfo	*cacheInfoPtr;
{
    register List_Links	*linkPtr;
    List_Links	*dirtyList, *place;

    dirtyList = &cacheInfoPtr->backendPtr->dirtyListHdr;

    /*
     * If the file has not already been synced, move the file up the
     * dirty list to the front or right behide the last synced file.
     */
    if (!(cacheInfoPtr->flags & FSCACHE_FILE_FSYNC)) {
	/*
	 * Move down the list until we reach the file or the first non
	 * synced file. 
	 */
	place = (List_Links *) cacheInfoPtr;
	LIST_FORALL(dirtyList, linkPtr) {
	    if ((linkPtr == (List_Links *) cacheInfoPtr) ||
		!(((Fscache_FileInfo *) linkPtr)->flags & FSCACHE_FILE_FSYNC)) {
		place = linkPtr;
		break;
	    }
	}
	cacheInfoPtr->flags |= FSCACHE_FILE_FSYNC;
	if (place != (List_Links *) cacheInfoPtr) {
	    List_Move((List_Links *)cacheInfoPtr, LIST_BEFORE(place));
	}
    }
    StartBackendWriteback(cacheInfoPtr->backendPtr);
}


/*
 * ----------------------------------------------------------------------------
 *
 * Fscache_FileWriteBack --
 *
 * 	This function forces all blocks for the file identified by 
 *	*hdrPtr in the range firstBlock to lastBlock to disk (or 
 *	the server).
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	All dirty blocks in the cache for the file are written out.
 *
 * ----------------------------------------------------------------------------
 *
 */
ENTRY ReturnStatus
Fscache_FileWriteBack(cacheInfoPtr, firstBlock, lastBlock, flags,
	blocksSkippedPtr)
    register Fscache_FileInfo *cacheInfoPtr;	/* State to force out. */
    int		firstBlock;	/* First block to write back. */
    int		lastBlock;	/* Last block to write back. */
    int		flags;		/* FSCACHE_FILE_WB_WAIT | FSCACHE_WRITE_BACK_INDIRECT |
				 * FSCACHE_WRITE_BACK_AND_INVALIDATE. 
				 * FSCACHE_WB_MIGRATION. */
    int		*blocksSkippedPtr; /* The number of blocks skipped
				      because they were locked. */
{
    register Hash_Entry	     *hashEntryPtr;
    register Fscache_Block    *blockPtr;
    BlockHashKey	     blockHashKey;
    int			     i;
    ReturnStatus	     status;
    Boolean		     fsyncFile;
    enum  {ENTIRE_FILE, SINGLE_BLOCK, MULTI_BLOCK_RANGE} rangeType;

    LOCK_MONITOR;

    *blocksSkippedPtr = 0;

    fsyncFile = FALSE;
    /* 
     * First classify the type of writeback being requests as either involving
     * a single file block, the entire file, or a multiple-block range.
     */
    if ((firstBlock == lastBlock) && (firstBlock >= 0)) {
	rangeType = SINGLE_BLOCK;
    } else if ((firstBlock == 0) && 
	        ((lastBlock == FSCACHE_LAST_BLOCK) || 
	        (lastBlock == cacheInfoPtr->attr.lastByte / FS_BLOCK_SIZE))) {
	rangeType = ENTIRE_FILE;
    } else {
	rangeType = MULTI_BLOCK_RANGE;
    }

    /*
     * Clear out the host down and no disk space flags so we can retry
     * for this file.
     */
    cacheInfoPtr->flags &= 
		    ~(FSCACHE_SERVER_DOWN | FSCACHE_NO_DISK_SPACE | 
		      FSCACHE_DOMAIN_DOWN | FSCACHE_GENERIC_ERROR);

    if ((cacheInfoPtr->blocksInCache == 0) ||
	(flags & FSCACHE_WRITE_BACK_DESC_ONLY)) {
	/*
	 * If file is on dirty list and has no blocks then it 
	 * descriptor is dirty.  Force the descriptor out 
	 * waiting if the user specified to.
	 */
	if ((cacheInfoPtr->flags & FSCACHE_FILE_ON_DIRTY_LIST) &&
	    (flags & FSCACHE_WRITE_BACK_DESC_ONLY)) {
	    StartFileSync(cacheInfoPtr);
	    if (flags & FSCACHE_FILE_WB_WAIT) {
		while (cacheInfoPtr->flags & FSCACHE_FILE_ON_DIRTY_LIST) {
			(void) Sync_Wait(&cacheInfoPtr->noDirtyBlocks, FALSE);
		}
	    }
	}
	UNLOCK_MONITOR;
	return(SUCCESS);
    }

    SET_BLOCK_HASH_KEY(blockHashKey, cacheInfoPtr, 0);

    if (lastBlock == FSCACHE_LAST_BLOCK) {
	if (cacheInfoPtr->attr.lastByte > 0) 9   >   ?   3   @   ,   A   ,   B   C   D   E   <   F   ,      G   T   I   J   ,   G      K      (         M   ,   <      N   O   I   P   Q      <   C   R   9   S   9   T   U   ,   P   j   C   P   k   <   O   `      a   b   !   L   \   Z   [   Y   ,   Z   ^   ]   Z   ^   _   ,   Z   I   d      d      x   D   W   X      )   c   f   O   e   ,   f   g   h   i   P   ‹   r   ,   s   9   ,      d   t   C   O   {      ,   G   <   i   I   m   ,   <   C   n   h   I   i   o   ,   T   p   T   q   v   9   S            ‰   9   ,   H   *                     	   
      
                        
                              
                                 
          !   "   #      !   "   $   "   +   ,   -   .      !   "   /            0   
   1   2   3   4   5   6      7   8   9   :   ;   3   ,   <   =   9   >   ?   3   @   ,   A   ,   B   C   D   E   <   F   ,      G   T   I   J   ,   G      K      (         M   ,   <      N   O   I   P   Q      <   C   R   9   S   9   T   U   ,   P   j   C   P   k   <   O   `      a   b   !   L   \   Z   [   Y   ,   Z   ^   ]   Z   ^   _   ,   Z   I   d      d      x   D   W   X      )   c   f   O   e   ,   f   g   h   i   P   ‹   r   ,   s   9   ,      d   t   C   O   {      ,   G   <   i   I   m   ,   <   C   n   h   I   i   o   ,   T   p   T   q   v   9   S            s   9   ,   *                     	   
      
                        
                              
                                 
          !   "   #      !   "   $   "   +   ,   -   .      !   "   /            0   
   1   2   3   4   5   6      7   8   9   :   ;   3   ,   <   =   9   >   ?   3   @   ,   A   ,   B   C   D   E   <   F   ,      G   H   I   J   ,   G      K      (            ,      m   ,   <   C   n   e   ,   `      a   b   !   L   \   Z   [   Y   ,   Z   ^   ]   Z   ^   _   ,   Z   I   N   O   I   P   Q      <   C   R   9   S   9   T   I   i   o   ,   T   p   T   q   G   d      9   n      ,   G   <   i   I   r   ,   s      d   t   C   n   O            s   9   ,   *                     	   
      
                        
                              
                                 
          !   "   #      !   "   $   "   +   ,   -   .      !   "   /            0   
   1   2   3   4   5   6      7   8   9   :   ;   3   ,   <   =   9   >   ?   3   @   ,   A   ,   B   C   D   E   <   F   ,      G   H   I   J   ,   G      K      (            ,      m   ,   <   C   n   e   ,   `      a   b   !   L   \   Z   [   Y   ,   Z   ^   ]   Z   ^   _   ,   Z   I   N   O   I   P   Q      <   C   R   9   S   9   T   I   i   o   ,   T   p   T   q   G   d      9   n      ,   G   <   i   I   r   ,   s      d   t   C   n   O            s   9   ,   *                     	   
      
                        
                              
                                 
          !   "   #      !   "   $   "   +   ,   -   .      !   "   /            0   
   1   2   3   4   5   6      7   8   9   :   ;   3   ,   <   =   9   >   ?   3   @   ,   A   ,   B   C   D   E   <   F   ,      G   H   I   J   ,   G      K      (            ,      m   ,   <   C   n   e   ,   `      a   b   !   L   \   Z   [   Y   ,   Z   ^   ]   Z   ^   _   ,   Z   I   N   O   I   P   Q      <   C   R   9   S   9   T   I   i   o   ,   T   p   T   q   G   d      9   n      ,   G   <   i   I   r   ,   s      d   t   C   n   O            s   9   ,   *                     	   
      
                        
                              
                                 
          !   "   #      !   "   $   "   +   ,   -   .      !   "   /            0   
   1   2   3   4   5   6      7   8   9   :   ;   3   ,   <   =   9   >   ?   3   @   ,   A   ,   B   C   D   E   <   F   ,      G   H   I   J   ,   G      K      (            ,      m   ,   <   C   n   e   ,   `      a   b   !   Πρ  µ                    Β2‚)}r°)Β2‚)Β2‚)ν΄     Χa  Cε      Πρ  µ                    Ε2‚)}r°)Ε2‚)Ε2‚)δ΄     Ψa  Fε      Πρ  µ                    Η2‚)}r°)Η2‚)Η2‚)β΄     Ωa  Gε      Πρ  µ                    Τ2‚)}r°)Τ2‚)Τ2‚)α΄     έa  >ε      Πρ  µ                    Υ2‚)}r°)Υ2‚)Υ2‚)ΰ΄     ήa  ?ε      Πρ  µ                    δ2‚)}r°)δ2‚)δ2‚)ί΄     ίa  =ε      Πρ  ύ{  ›                |ύ‚)\V³)κ•ƒ)κ•ƒ)ή΄     :}        Πρ   ΄{  ›   Ώ             ψaƒ)½t°)ϋaƒ)ψaƒ)Χ΄     ‰Φ  ‘<      Πρ   ΄      K             [ƒ)—w°)')')Υ΄     α•  M     Πρ   ¤Ώ      ^             Zδ‘)|/±){δ‘)^δ‘)Ο΄     ²# ,      Πρ   ΄	      pH             µ_ƒ)y°)ΏΘ΅)¶_ƒ)Η΄ Ώ΄ ·΄ ―΄ §΄     ίΥ  B‡      Πρ  µ      	              ®‚©)S΄)®‚©)®‚©)¦΄     +' µΆ     Πρ   mµ      •             ¨–©)bΊ±)Ι–©)«–©)΄     * 0     Πρ   ΄µ      Ρj             ?J©)r°)aJ©)GJ©)—΄ ΄ ‡΄ ΄ w΄ o΄ g΄      OΤ     Πρ  ύµ                   μ,‚))V³)~J©)~J©)f΄     J  )Ξ     Πρ  ύ{  ›                ‚)ΗV³)‡®©)‡®©)e΄       ¬«      Πρ   ${  ›   i             Έ®©)ƒv°)Έ®©)Έ®©)d΄     ‰. γ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ,+?H*V!]@RMQG003]I1`G+3]<<&H.G7^MKIBS!D8/7/EZ
6v-MM>U7@73B-*UNC,_".K;D_Z')UDRK?5%E3T_9.K.9L\R<`P[EZWS`E!F2<;D6
95-M,5UJ6C`_R+8D=:.;RM'8D(1YL?UX^PCPUM@MZZV^BOL(Y0Y<TML\NR7:J+G)
z@-M`%BE+?G/SC+'[,G,PK*0Z->@7QJ/I&BU!&N?R2F]_"6\Q;S!F.UF2;GLU'W(
[N-M3?PS`LICZTXINBFNK>4`OX`?@RWUCZ/40C&5O^DM?UZ`ITM^"64MC+8ZTHN0
HE-MMP1OQA?TD.^\.R1]^UU"&",24T>@1]^>!#0;TV3;*<4L5KTM>VO+9DHXNI.5
N.-MS)(N46Z&`*RX721@+C).+?1Z_-^]1GKTVA_"0V?\I7Q@RJ[L>73SU"NGG_UA
q=-MT\W:FV]:IJ)6LS<X`+145'S+PCP?-C)%98RBN'2FG<]EBV?/S6G_/?AF[K'G
au-MX2Z1EEKEJ=]ZU/4?:UGY)+9R?8NX^,Q7GVQ7LAV6!(5+8I3&(*?=P.U4="7^
i0-ME`^9<CI4>:1U&&^J<\(7V"C<(O<2X1P4=;B$171V]#4DM[YY?6_A][.RZ3?N
T0-MU1O9;:W;USWS@!U:9G_]GBK$Y45&1:?+3N6\7`UUI\O3_.Y45I$_T6#]H?*?
4p-M&?8EE&NXSJB_[$#JX"X_+=OCJNXMH&T\GT;`BA5`P.W#+T_1__TGCQY5^*>9
FU-MYA+.>K7!KY::_Q+!H!:0K,1[BYW[:Z4$BN5U51V43J?_@Y1TZ:E0+Z[%_6AO
l^-M=*K&X]<I&\TOGJ>2KY"GD*J$_R*O(&-L(Y]/IN(I65GZF*RLX&L]:3_/.X#*
pK-MO"/(VA@YKDWAM1'GQ;T][7[W^XQ-\L>1=R.[D09&JD.FC8$BKD6LC!D-S$7^
N6-MJW?M%46D*NEM(313?3(KYNMGKT]!W"<W[@4_3"T;4^`?BL*P0+F"-$?WFID>
!<-M7RZ>)#/J#W!Y%LOY-EO(_SY5GE7^#.'5X0F^@QHJ?X^OJEJ?`NK6R>O=!749
$P-MU*"\/ALMWS*8602[*K4J_(+@WT:^8OE/!-DTPSE!Y)>,3*%IQ[AN3EL.$<[8
1V-M\->_Y#YE())GJ]TAXM3G]-"S0V;V*>:_&V<O])JSM.!]YA^?UI_^?A81R6C6
<1-M]Q%B+L`,QB->5C"$,3",H*C)]BN-O5.%D/Q=7+1GULEV,M]7E^W157Z>O>"W
*y-M6\>O_=8"24F=;'/CO&SO\SL+KL/ZZ<CH[+3Q=-<HQD?Y.;W2,=OA#Y9OBB:/
Qi-M>*[PWDF\8WA,EB#*^[D^CDK3B84J=*W'[*FPI_H:6Y_;^K7^)'\2.;;Z4B==
I2-M\6/D1Y2]%&?)Q&9IS`K5)5QQ-1O4MZEQ!=`S62.00K9&TY?HR"2"R"`-D6Q"
y,-M:_N(O;!G?0;O7`P=*Y;?#2"]ET;6<HB!W;K^P$MEV*P+D[2=4'VU^06>7.^N
j0-M9J[(HTS8S2WM((^$TX?S$-%^]I?,]1+?*T'/`-5*3"7>SW<NF<N,6FRG>%#?
,U-M"+^0QWC:"+\H01+D^YW'>U.I/MSWF/;R['+V[@Q8L9*JO[!_86%A_%8:D:?Z
o*-MPUAM_+_KE\4#8R+[C.[52[_MN^/Z:CGI?N4F^9S?_%[Q_`XZ?'\!2]TW^DHG
#%-M$T):'2[`R:[])XON9[R6A/>=U58*.K0>Z`C?,M<D"U^!L_"C>9@>9`WEKO'V
bz-M[/S'T>UVN"?E--[,<,7>M2N@#16AQR1R7@'OY<[%9/?Y==>(1Q@5K:JZTR]6
aK-M$5H:O!A!@Y">1J\T-U;"+8VL0K>Y;W-;WJ.I1MPG.V\VQ_)MS"0-Z(&3"]]X
;1-MENS7U8>/U![[L,-9&U<Q24$U7BFY494*>$\QD,I"_H&$/[)?UI/`4#(^'84S
e/-M(W^IIDAHC1#CJ&D<4,.OV%JQ67<.AMX67.%\E:,,_Y7!>_7"-^=$B`5Q!K\G
MK-MVTPW>IQH.!!@`R<^3MJ_:?W>CU+_^%EUV.H2LY[#D.`_08QQ2;QE-T:D^PFV
V5-M3;1&PJT7*=S$[U/4IVXI2V^_U/G[?:9=&3\7/T"&)ILDVP)]H!&_H<Q#<`VK
8S-M74&S3:+28Y<@_@O<>%C7^ZG2F<GSSXY>[%S'2E9.JE?1:N+:E@)X!B;Y%&%#
Ds-M\$2_Y48TQ4>-'Q+P(\\G$@*:L$GQ668M6V"VIVRHZ?B7*?>Q-2W&/Z-O]_4^
_5-M;M\K+.;'*RWGM/9)[19'N@A)@(XZEN@KZ9GT\($/U?&><M[MC^6$+77A`6Y9
zB-M70_>,ZE3)V9A833,_,0R#Z3-#39M)M%-M0)AQ%T]ASF&R^)L%]@I=/=I[E(?
=r-M"8>_U^>I\UGFM4WWR78"S_1Q]>Z%32^CR#W<+]WM:+=.T]"J*6TGLI^BQ!CC
B5-MI9I59U%K_.^K<#R=&N,`[^4;4Q4F::_Y3(/WKL6XN(CIFD;H9H4SB9KEII]:
Vk-M)/Z(2$UG\\(9ZH.H"ZNV@-K01UJMMKX=YE.<0UG\C:@PW(R4^71\+HOF?2"/
bE-M;R7[P3OT#GK+]#\R7W*]X=EEUT5?:+VDFM4=VHJ_S_;2ZI*&X.U&@+&YWU^N
gC-MF/FQ%,GAFHSRSNEAM>?<.^UH905%5VM+[*3/_C-Z>Z.UU+ARY_X?I[BBG4L;
CY-M*6,_!4#[J+KMFOJY.G:^_R^O]^KH9#)2$/KX1OISC<5M3GM6/QYP,/LQ9U;Z
5!-M.O"Q7QA_[@!OSCWY'[BS<O%^Q6VT?\.U\6R<'-LN+X&T<1&C3^D;N0`C4C*)
;>-M^Y7>0AQ^Q4^-;.4:G^JW#$`RERCMN**>;;I5RB$DU4%R:J"$-_"%1YNU%S/+
G]-ML5[U?\@?&YI_181#=N93X2<PW84?@4%+:'HS-/PN[\S\7IXUVW=.)D84W[@]
6F-M%VBY1\?W[9%Z/3Y/OJHV*)]5D]&"CJJIT\F/*5S\\B\EBXE'8DN-T\0@E>$)
,J-M\:7@!>?B%3D&U$-M*S0):UX=?E6>(T1FXC&1,X,?'/XY?L1O^^#OU-_<3WJ]
[\-MQ)P3LHSB61'D^^UOE>^;:2J]GHAQ?JD7G#>"/\J2XZ%.H,(2^G[52AHB9T#P
U*-MVOH<YY`W*C9*YS=2E0U"'2>6NYLF:EON!1Q]]AJ*@V8.BK:TH1W8/UB1_7DL
K;-M>+#]"/]="9Q6/4F'S+&8]F6./'EO<;SMUFG`1;)2V6F'8I:B1],MS(N2F4&P
V3-MH.[;CDM6#9TXC'UM(1!0"&U-[</%"W%RIWK%O5O//L=IELT!6,<+5F<Q`)Y!
GM-M>.OQS>6=N_7ER>NL_OLZF&<;-Z-RV;^&XRB8DQ#S$>.CY/1Y_SSX[OM^E_)=
iU-M=QKN_7?KV$GP5.XM?8.F#J\:Y,>9M9G:<(_S!K>#6[-Q9DS\'0PB?OG=(1F*
^G-MN(-N+AFB?91_VD@$]#<4*G_?GLP]Q3=/YPO@J)-;?<532KTLT'!4CJ!=%1S:
`e-MHIZ(_];KH2)A.K7DS`B>%#EE7/KN2\S'I_QGSFRJ<>W_/FT],Z=BONX`F!Z"
?!-M,1WC%9;N6=O"+9(T[STV'5%@C-3?$1-'6`<F*'FGAM4NC=%M+KY'Y&ECFBL@
**-MOFUJVDMLMLX89$OW1T+#QSEF+-=WR`AHHX'1B!S3Q:!G-]FE^D>L<SE"(,NE
LS-M9G/I=-^N_;PW%3GMC(KX17:R;K/9SD:A'M.;[819U$:Q&HFZS\F=V+EICYI$
Q'-M+Q]9H:X$XX;OOJ-#\B$1!,:XS#.^J3TP204&M5Z%F^(3]/]!C*_0UOR/`,@@
3"-MIH_H\&QC&U98&=7TT.<24"[:0PG2=A\$P5(T#*XWA\])*%N$/4KFFGVDCHM/
1S-M_9MM(KC*)1B_%E4=0I"O6S8[I$W35[?<8=A!S,C5D(#/X7M\QG;S&G;\X92Z
n?-M=75F0"WRMD%J`(O[    4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444   4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444   4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444   4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444   4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444   4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444   4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444   4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444Πρ   ¤µ      g            °,‚)ζW¨)Υ,‚)ψ})CΞ Zΰ
 bΰ
 jΰ
 rΰ
 zΰ
 ‚ΰ
 ΰ
 ’ΰ
 ΰ
 K>     QI  Τ®     Πρ  ύ{  ›                μ®©)i)μ®©)μ®©)B>     ‘. My     Πρ   ΄{  ›              ρ®©)ς®©)ς®©)ς®©)    . »N     Πρ   ΄{  ›   Ό              ς®©)Π)ϋ®©)σ®©)A>     . ΎN     Πρ   ΄{  ›   ό             ό®©)Π)―©)ώ®©)@>     . ½N     Πρ   ΄{  ›   Ρ             ν®©))―©)ξ®©)>>     ”. δ      Πρ   ΄{  ›   /             π®©)Π)―©)π®©)<>     –. ΌN     Πρ  ύ{  ›                μ®©)i)―©)―©);>     ’. ΊN     Πρ  ν{  ›                Oύ‚)=)―©)―©):>     gz  M¤      Πρ  ύ{  ›                ‡®©)i)+―©)+―©)9>     €. ΰ      Πρ   ΄{  ›   k)             ―©)Π)8―©)―©)$> ,> 4>     ΅. ΏN     Πρ   ύ{  ›   w’            ―©))>―©)―©),; = = ;= K= S= [= c= k= s= e‹     £. ΐN     Πρ   ¤	      ―"             qn)Π)S®)S®)Ϋ< Σ< Λ<     µ1 ηK                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ,+?H*V!]@RMQG003]I1`G+3]<<&H.G7^MKIBS!D8/7/EZ
6v-MM>U7@73B-*UNC,_".K;D_Z')UDRK?5%E3T_9.K.9L\R<`P[EZWS`E!F2<;D6
95-M,5UJ6C`_R+8D=:.;RM'8D(1YL?UX^PCPUM@MZZV^BOL(Y0Y<TML\NR7:J+G)
z@-M`%BE+?G/SC+'[,G,PK*0Z->@7QJ/I&BU!&N?R2F]_"6\Q;S!F.UF2;GLU'W(
[N-M3?PS`LICZTXINBFNK>4`OX`?@RWUCZ/40C&5O^DM?UZ`ITM^"64MC+8ZTHN0
HE-MMP1OQA?TD.^\.R1]^UU"&",24T>@1]^>!#0;TV3;*<4L5KTM>VO+9DHXNI.5
N.-MS)(N46Z&`*RX721@+C).+?1Z_-^]1GKTVA_"0V?\I7Q@RJ[L>73SU"NGG_UA
q=-MT\W:FV]:IJ)6LS<X`+145'S+PCP?-C)%98RBN'2FG<]EBV?/S6G_/?AF[K'G
au-MX2Z1EEKEJ=]ZU/4?:UGY)+9R?8NX^,Q7GVQ7LAV6!(5+8I3&(*?=P.U4="7^
i0-ME`^9<CI4>:1U&&^J<\(7V"C<(O<2X1P4=;B$171V]#4DM[YY?6_A][.RZ3?N
T0-MU1O9;:W;USWS@!U:9G_]GBK$Y45&1:?+3N6\7`UUI\O3_.Y45I$_T6#]H?*?
4p-M&?8EE&NXSJB_[$#JX"X_+=OCJNXMH&T\GT;`BA5`P.W#+T_1__TGCQY5^*>9
FU-MYA+.>K7!KY::_Q+!H!:0K,1[BYW[:Z4$BN5U51V43J?_@Y1TZ:E0+Z[%_6AO
l^-M=*K&X]<I&\TOGJ>2KY"GD*J$_R*O(&-L(Y]/IN(I65GZF*RLX&L]:3_/.X#*
pK-MO"/(VA@YKDWAM1'GQ;T][7[W^XQ-\L>1=R.[D09&JD.FC8$BKD6LC!D-S$7^
N6-MJW?M%46D*NEM(313?3(KYNMGKT]!W"<W[@4_3"T;4^`?BL*P0+F"-$?WFID>
!<-M7RZ>)#/J#W!Y%LOY-EO(_SY5GE7^#.'5X0F^@QHJ?X^OJEJ?`NK6R>O=!749
$P-MU*"\/ALMWS*8602[*K4J_(+@WT:^8OE/!-DTPSE!Y)>,3*%IQ[AN3EL.$<[8
1V-M\->_Y#YE())GJ]TAXM3G]-"S0V;V*>:_&V<O])JSM.!]YA^?UI_^?A81R6C6
<1-M]Q%B+L`,QB->5C"$,3",H*C)]BN-O5.%D/Q=7+1GULEV,M]7E^W157Z>O>"W
*y-M6\>O_=8"24F=;'/CO&SO\SL+KL/ZZ<CH[+3Q=-<HQD?Y.;W2,=OA#Y9OBB:/
Qi-M>*[PWDF\8WA,EB#*^[D^CDK3B84J=*W'[*FPI_H:6Y_;^K7^)'\2.;;Z4B==
I2-M\6/D1Y2]%&?)Q&9IS`K5)5QQ-1O4MZEQ!=`S62.00K9&TY?HR"2"R"`-D6Q"
y,-M:_N(O;!G?0;O7`P=*Y;?#2"]ET;6<HB!W;K^P$MEV*P+D[2=4'VU^06>7.^N
j0-M9J[(HTS8S2WM((^$TX?S$-%^]I?,]1+?*T'/`-5*3"7>SW<NF<N,6FRG>%#?
,U-M"+^0QWC:"+\H01+D^YW'>U.I/MSWF/;R['+V[@Q8L9*JO[!_86%A_%8:D:?Z
o*-MPUAM_+_KE\4#8R+[C.[52[_MN^/Z:CGI?N4F^9S?_%[Q_`XZ?'\!2]TW^DHG
#%-M$T):'2[`R:[])XON9[R6A/>=U58*.K0>Z`C?,M<D"U^!L_"C>9@>9`WEKO'V
bz-M[/S'T>UVN"?E--[,<,7>M2N@#16AQR1R7@'OY<[%9/?Y==>(1Q@5K:JZTR]6
aK-M$5H:O!A!@Y">1J\T-U;"+8VL0K>Y;W-;WJ.I1MPG.V\VQ_)MS"0-Z(&3"]]X
;1-MENS7U8>/U![[L,-9&U<Q24$U7BFY494*>$\QD,I"_H&$/[)?UI/`4#(^'84S
e/-M(W^IIDAHC1#CJ&D<4,.OV%JQ67<.AMX67.%\E:,,_Y7!>_7"-^=$B`5Q!K\G
MK-MVTPW>IQH.!!@`R<^3MJ_:?W>CU+_^%EUV.H2LY[#D.`_08QQ2;QE-T:D^PFV
V5-M3;1&PJT7*=S$[U/4IVXI2V^_U/G[?:9=&3\7/T"&)ILDVP)]H!&_H<Q#<`VK
8S-M74&S3:+28Y<@_@O<>%C7^ZG2F<GSSXY>[%S'2E9.JE?1:N+:E@)X!B;Y%&%#
Ds-M\$2_Y48TQ4>-'Q+P(\\G$@*:L$GQ668M6V"VIVRHZ?B7*?>Q-2W&/Z-O]_4^
_5-M;M\K+.;'*RWGM/9)[19'N@A)@(XZEN@KZ9GT\($/U?&><M[MC^6$+77A`6Y9
zB-M70_>,ZE3)V9A833,_,0R#Z3-#39M)M%-M0)AQ%T]ASF&R^)L%]@I=/=I[E(?
=r-M"8>_U^>I\UGFM4WWR78"S_1Q]>Z%32^CR#W<+]WM:+=.T]"J*6TGLI^BQ!CC
B5-MI9I59U%K_.^K<#R=&N,`[^4;4Q4F::_Y3(/WKL6XN(CIFD;H9H4SB9KEII]:
Vk-M)/Z(2$UG\\(9ZH.H"ZNV@-K01UJMMKX=YE.<0UG\C:@PW(R4^71\+HOF?2"/
bE-M;R7[P3OT#GK+]#\R7W*]X=EEUT5?:+VDFM4=VHJ_S_;2ZI*&X.U&@+&YWU^N
gC-MF/FQ%,GAFHSRSNEAM>?<.^UH905%5VM+[*3/_C-Z>Z.UU+ARY_X?I[BBG4L;
CY-M*6,_!4#[J+KMFOJY.G:^_R^O]^KH9#)2$/KX1OISC<5M3GM6/QYP,/LQ9U;Z
5!-M.O"Q7QA_[@!OSCWY'[BS<O%^Q6VT?\.U\6R<'-LN+X&T<1&C3^D;N0`C4C*)
;>-M^Y7>0AQ^Q4^-;.4:G^JW#$`RERCMN**>;;I5RB$DU4%R:J"$-_"%1YNU%S/+
G]-ML5[U?\@?&YI_181#=N93X2<PW84?@4%+:'HS-/PN[\S\7IXUVW=.)D84W[@]
6F-M%VBY1\?W[9%Z/3Y/OJHV*)]5D]&"CJJIT\F/*5S\\B\EBXE'8DN-T\0@E>$)
,J-M\:7@!>?B%3D&U$-M*S0):UX=?E6>(T1FXC&1,X,?'/XY?L1O^^#OU-_<3WJ]
[\-MQ)P3LHSB61'D^^UOE>^;:2J]GHAQ?JD7G#>"/\J2XZ%.H,(2^G[52AHB9T#P
U*-MVOH<YY`W*C9*YS=2E0U"'2>6NYLF:EON!1Q]]AJ*@V8.BK:TH1W8/UB1_7DL
K;-M>+#]"/]="9Q6/4F'S+&8]F6./'EO<;SMUFG`1;)2V6F'8I:B1],MS(N2F4&P
V3-MH.[;CDM6#9TXC'UM(1!0"&U-[</%"W%RIWK%O5O//L=IELT!6,<+5F<Q`)Y!
GM-M>.OQS>6=N_7ER>NL_OLZF&<;-Z-RV;^&XRB8DQ#S$>.CY/1Y_SSX[OM^E_)=
iU-M=QKN_7?KV$GP5.XM?8.F#J\:Y,>9M9G:<(_S!K>#6[-Q9DS\'0PB?OG=(1F*
^G-MN(-N+AFB?91_VD@$]#<4*G_?GLP]Q3=/YPO@J)-;?<532KTLT'!4CJ!=%1S:
`e-MHIZ(_];KH2)A.K7DS`B>%#EE7/KN2\S'I_QGSFRJ<>W_/FT],Z=BONX`F!Z"
?!-M,1WC%9;N6=O"+9(T[STV'5%@C-3?$1-'6`<F*'FGAM4NC=%M+KY'Y&ECFBL@
**-MOFUJVDMLMLX89$OW1T+#QSEF+-=WR`AHHX'1B!S3Q:!G-]FE^D>L<SE"(,NE
LS-M9G/I=-^N_;PW%3GMC(KX17:R;K/9SD:A'M.;[819U$:Q&HFZS\F=V+EICYI$
Q'-M+Q]9H:X$XX;OOJ-#\B$1!,:XS#.^J3TP204&M5Z%F^(3]/]!C*_0UOR/`,@@
3"-MIH_H\&QC&U98&=7TT.<24"[:0PG2=A\$P5(T#*XWA\])*%N$/4KFFGVDCHM/
1S-M_9MM(KC*)1B_%E4=0I"O6S8[I$W35[?<8=A!S,C5D(#/X7M\QG;S&G;\X92Z
n?-M=75F0"WRMD%J`(O[    4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444   4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444   4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444   4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444   4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444   4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444   4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444   4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444   4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444   4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444   4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444   4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444   4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444   4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444   4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444       H          K          H          K          H          K          H          K          H          K          H          K          H          K          H          K          H          K          H          K0  ?       Κ         H          K          H          K          H          Kπ     8   Η         ΙΆ         ΙB  '   @   ΙB  2   `   ΙB  ;   €   ΙB  J       ΙB  X   ΐ   Ι g      Ι2 t   @  Ιb    €  Ι’         Θ         ΚΒ        H          K          H          K@ 6      ΗR  ;       ΙB  C       ΙB          Θ  P       Κ U   (   Η" Z       ΙB  _       ΙB  e   @   ΙB  o   `   ΙB  z   €   ΙB  „       ΙB     ΐ   ΙB  ’   ΰ   ΙB        ΙB  ¦      ΙB          Θb         Κb        H          K          H          Kΰ )      ΗΆ  9       Ι  @       ΙΆ  P   @   ΙB  [   `   Ι f   €   Ι2 r       ΙB  ~   ΐ   ΙB         Θ  ‡       ΚR —   <   ΗB §       Ι² ®   €   ΙB  ΄       Ιβ ½   @  ΙB  Ζ   `  Ι Λ   €  Ι" Τ   ΐ  ΙR         Θ²  ΰ       Κ‚ π   (   ΗΒ ό       Ιβ   €   Ι 
     ΙB    5   ΚB      Ιr         ΘR (      ΚΆ 4  T   ΗR >      Ι B  ΰ  ΙB  I     ΙB  O     Ι [  @  Ι2 g  `  Ιb         Θ r      Κ’ |      Η ‡      Ις       ΙB  •  @   ΙB    `   ΙB  Ά  €   ΙΆ  ©      ΙΆ  ²  ΐ   ΙB  ¶  ΰ   ΙB          Θb Ώ      Κ Κ     Ηr Υ      ΙB  ά      ΙB  β  @   ΙB  ι  `   ΙB          Θ ξ      Κb ω  (   ΗB       ΙB        ΙΒ   @   ΙB     `   Ι *  €   ΙB  5      ΙB  <  ΐ   ΙΆ  C  ΰ   ΙΆ  L     ΙB  P     ΙB          Θ‚ V      Κβ b     Η² g      ΙB t     ΙR      Ιb      Ιr         ΘR       Κ‚ ©      Κ²        H          Kp  *      ΗR  /       Ι 5   @   Ι2         Θ  <       Κb        H          K          H          Kp  0      ΗR  ;       Ι C       Ι2         Θ  K       Κb        H          K          H          K@ 5       Ηb  :       Ι ?   ΐ   Ι2 K   ΰ   ΙB          Θ  S       Κb f      ΗΒ  q       ΙΒ        ΙB  “   @   Ι         Θr         Κβ «       Η" °       ΙB µ   ΐ   Ιr Α   ΰ   ΙB          Θ  Ι       ΚΆ        H          K          H          KP 8       ΚΆ  K       ΚΆ  [       ΚΆ  k       ΚΆ  |       ΚB        Ηβ         ΙΆ  ™       ΙΆ  £   @   ΙΆ  ΄   `   ΙΆ  Δ   €   ΙΆ  Ο       ΙB          Θb  Χ       Κ ι       ΚΆ  ώ       ΚΆ        ΚΆ  *     Η² /      Ιb 9     Ι‚ C     ΙΆ O     ΙΒ [     Ιβ i     Ι y     Ι"         Θ" …      ΚB •     Η"       ΙΆ §      Ι’  ²  0   Ι’  ½  @   ΙΆ          ΘΒ Κ      Κ ί      ΚB  ρ      ΚB        ΚΆ       Ης       Ι2      ΙR )      ΙΆ  2  @   ΙB  ;  `   ΙB  J  €   ΙB  Z      ΙB          Θb a      Κr n     Η’ s      Ι      Ις      Ι      Ι2 ―     ΙR Α     Ιr Υ     Ι’         Θ ε      Κ² π     Η υ      Ι       Ι’    0   Ι’  +  @   ΙΆ          ΘΆ @      ΚB P      ΚΆ  ^      ΚB  k      ΚB         H          K          H          K          H          K` 0       ΚB  >      Ηb  L       Ι R   @   Ι2         Θ"  W       ΚB e      Η  u       ΙΆ {       Ι „      Κβ –   ΐ   Ι         Θr  £       ΚB ³       Κr ½   0   Η² Ν       Ι Σ   @   ΙB  Χ   `   ΙB  ά   €   ΙB  α       Ι ζ   ΐ   ΙB  ρ   ΰ   Ι ό      ΙB       Ιr   `  ΙB          Θς  &      ΚΆ 6  >   Κ ?      Κ L     ΗB Q      Ιb W  @   ΙB  ^  `   ΙΆ  b  €   ΙB          Θβ l      Κ’        H          K  4       Κ  :      Ηr  H      Κ [       ΙB `       Ιr         Θ"  e       ΚΆ u      Η²         Ι         Θ‚         Κ Ά      Η" ¨       ΙB  ­       Ιb ²   @   Ιr Έ   €   ΙB          ΘΒ  ½       ΚΆ Ε      Η‚ Ο       ΙB  Τ       Ι Ϊ   `   Ι2         Θ2 ί       ΚB λ       Κr ψ   `  Η‚        Ι²       Ιβ 
  ΐ   Ι   @  ΙB    `  ΙB   @
  ΙΆ    `
  Ι² $  €
  ΙΒ +   
  Ι 0  ΐ
  Ιβ =  P   Κς H  ΰ
  Ι"         ΘΆ K      ΚR U     Η `      Ι‚ e      Ι²         Θ’ q      Κβ ~      ΚB                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444   4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444   4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444   4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444   4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444   4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444   4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444   4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444ν       ΙB  φ   ΐ   ΙB  ώ   ΰ   ΙB       ΙB       ΙB    @  Ι #  ΐ  ΙR (  ΐ  Ι² 1  `  Ι :  ΐ  Ιr C  ΰ  Ι‚         ΘR J      Κ² X     Η² ]      Ι         Θ‚ b      Κr u  0   Η² …      ΙB  ‹      ΙB  ”  @   ΙB  ™  $   Η’       Ι §      Ι2 ¬  $   Ηr ±      ΙΒ Ί  €   Ις         Θ2 ΐ      Ι"         Θ Θ  `   ΙR         ΘΒ Ξ      Κ‚        H          K          H          K          H          K          H          K 4      Η’  9       Ι‚  ?      Ι‚  E      Ι‚  K      Ι‚  Q       Ι‚  W   (   Ι‚          Θ  ]       Κ n      Ης  s       Ιb    0   Ι’ †   `   Ι’          ΘΆ  ‹       ΚΒ        H          K          H          KP	 3       ΚΆ  C      Η’  H       Ι’  U      Ι’  b       Ι‚  r   (   Ι‚  ‚   0   Ι’          Θ"  ‰       Κ —   ,   Ηb        Ιb £   p   Ι’  °   €   Ι’  ½      Ι‚  Ν      Ι‚  έ       Ι’  δ   °   Ι’ τ   ΰ   ΙΆ       ΙΒ   @  ΙΆ          ΘΆ  "      Κς 0     ΗR 5      ΙR ?     Ιr G     Ι‚  U     Ι’  ^      Ι’  d  0   Ι’ o  =   Ι² u  @   Ι‚  €  H   Ι‚  ‰  P   Ι’  ’  `   ΙΆ  ™  €   ΙΆ          Θr       Κ «     Η °      ΙΆ  ·      ΙΆ  Ό  @   Ι‚  Α  H   Ι‚  Κ  P   Ι’          Θb Ξ      Κ2 ή     ΗR γ      Ι‚  θ     Ι‚  μ     Ι‚  τ     Ι’ ϊ     Ι²         Θβ       Κ       ΚB  #     ΗB (      Ι’  0     Ι’  9      ΙΆ  @  @   ΙΆ  G  `   Ι2 Q  d   ΙR \  h   Ιr b  n   Ι’ l  p   Ι’  s  €   Ι’  |     Ι’          Θr ‰      Κ² —     Η²       Ι’  ¤     Ι’  ­      Ι’  ±  0   Ι’          ΘR Ί      Κ Θ     Η Ν      Ι‚       Ι‚  Χ     Ι’          ΘΒ ΰ      Κr ο  H   Η‚ τ      ΙB  ϋ      Ι   ΐ   Ι      Ιb         Θ"       ΚΒ %  H   Ης *      ΙΆ  6      Ι" ?  ΐ   ΙR J     Ι²         Θ’ O      Κ a  H   Η‚ f      Ι‚  r     Ι"  z     Ι2  ‚      Ιr ‹  ΐ   ΙΆ –     Ι	         Θ ›      Κb	 ­     Η ²      Ι’  µ     Ι’          Θ’ Ό      ΚΒ	 Ρ     Η2 Φ      Ι’  Ω     Ι’  ΰ      ΙΆ          Θβ ι      Κ"
 ϊ     Η²       Ι’       Ι’  	      ΙΆ    @   ΙΆ    `   ΙΆ          ΘB (      Κ‚
 9  L   ΗΒ >      Ιβ
 E  H   ΗΆ J      ΙB R      Ιr Z      ΙΆ e      Ι l      Ι r      Ι2 {      Ιb …      Ι’       ΙΒ       Ις         Θβ ”      Ι"         ΘΒ ™      ΚR ¨     Η2	 ­      Ι2  Έ     Ι’  ½      ΙΆ  Ε  @   Ι²         Θ Ν      Κ        H          K          H          K          H          Kΐ 4      ΗB  E       Ι         Θ  J       Κb [      ΗΒ  n       Ι‚  z      Ι‚  ƒ      ΙΒ    0   Ι"    p   ΙR         ΘR  ”       Κ² §   8   ΗΆ ·       Ι‚  »      Ι‚  Β      Ι’  Μ       ΙB  Π   @   Ι Χ   `   ΙB  ά   €   Ι" κ      ΙR χ   €  Ι’       Ι’       ΙΆ          Θ        Κ‚        H          K          H          K          H          K /       ΚB  >      Ηb  C       Ι K       ΙB          Θ"  R       Κ d   `   Η i       ΙB  v       ΙB  ‚   @   ΙB     `   ΙB  ›   €   ΙB  ¥       ΙB  ¬   ΐ   ΙB  Ί   ΰ   ΙB  Δ      ΙB  Ξ      ΙB  Ϊ   @  ΙB  ζ   `  ΙB  ρ   €  ΙB       ΙB    ΐ  ΙB  )  ΰ  ΙB  1     ΙB  C     ΙB  T  @  ΙB  e  `  ΙB  w  €  ΙB       ΙB  ™  ΐ  ΙB  £  ΰ  ΙB          Θr  ±      Κr ΐ    ΗΆ Ο      ΙB  Ϋ      ΙB  ε  @   Ι σ  `  ΙB    €  ΙB       Ι2         Θ" #      Κ’ 2  x  Ης <      Ις B     Ι"         Θ² H      ΚR R  |   Ηr `      Ι² e      ΙB  l  @   ΙΆ  x  `   ΙΆ    €   ΙΒ †      Ι   ΐ   Ιβ “  ΰ   Ις ™     Ι Ά     Ι ®  @  Ι" Ό  `  ΙB  Δ  €  ΙB  Κ     Ι2 Π  €  ΙB  Ω     ΙB  β  ΐ  Ιb ι  ΰ  Ιr τ     Ι‚      Ι’ 
     Ι         Θ       ΚB        H          K          H          K <      ΗΆ  G       ΙB  W       ΙB  g   @   ΙB  u   `   ΙB     €   ΙB         ΙB  ”   ΐ   ΙB          Θ          Κ’  ©       Κ Έ      Η Ζ       Ι’  Ν      Ι’          ΘΒ     `  Ηr ή       Ιr ζ   ΐ   ΙΆ ς   ΰ   Ι ω   ΰ  Ι2      Ιb                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444   4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444   4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444   4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444   4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444   4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444   4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444   4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444egPtr mappedAddr length VmMappedSegment .F42 mappedListHdr codeInfoPtr heapInfoPtr stackInfoPtr Vm_TaskInfo Vm_Accessibility  /users/kupfer/spriteserver/include/user/sprite.h  /users/kupfer/spriteserver/include/user/mach.h  /users/kupfer/spriteserver/include/user/list.h  /users/kupfer/spriteserver/include/user/sys/types.h u_char u_short u_int u_long ushort _physadr r physadr label_t val label_t _quad val quad _uquad val u_quad daddr_t caddr_t qaddr_t ino_t swblk_t size_t time_t clock_t dev_t off_t uid_t gid_t pid_t key_t fd_mask fd_set fds_bits fd_set  /users/kupfer/spriteserver/include/syncTypes.h  /users/kupfer/spriteserver/include/sys.h  /users/kupfer/spriteserver/include/user/fs.h Fs_Attributes serverID domain fileNumber type size numLinks permissions uid gid devServerID devType devUnit createTime accessTime descModifyTime dataModifyTime blocks blockSize version userType pad Fs_Attributes Fs_FileID type serverID major minor Fs_FileID Fs_UserIDs user numGroupIDs group Fs_UserIDs Ioc_RepositionArgs base offset Ioc_RepositionArgs Ioc_LockArgs flags hostID pid token Ioc_LockArgs Ioc_Owner id procOrFamily Ioc_Owner Ioc_MapArgs numBytes address Ioc_MapArgs Ioc_PrefixArgs prefix Ioc_PrefixArgs Ioc_WriteBackArgs firstByte lastByte shouldBlock Ioc_WriteBackArgs Ioc_MmapInfoArgs isMapped clientID Ioc_MmapInfoArgs Fs_TwoPaths pathLen1 pathLen2 path1 path2 Fs_TwoPaths .F49 maxKbytes freeKbytes maxFileDesc freeFileDesc blockSize optSize Fs_DomainInfo Fs_Prefix serverID domain fileNumber version flags prefix domainInfo Fs_Prefix .F50 bufSize buffer Fs_IOVector Fs_Device serverID type unit devPort mmapPort data Fs_Device Fs_TimeoutHandler Fs_PathName  /users/kupfer/spriteserver/include/user/mach.h  /users/kupfer/spriteserver/include/user/spriteTime.h  /users/kupfer/spriteserver/include/user/proc.h  /users/kupfer/spriteserver/include/user/fmt.h Fmt_Format  /users/kupfer/spriteserver/include/user/cfuncproto.h  /users/kupfer/spriteserver/include/user/bstring.h  /users/kupfer/spriteserver/include/user/cfuncproto.h  /users/kupfer/spriteserver/include/user/sys/types.h  ds3100.md/procMach.h .F52 magic numSections timeDateStamp symPtr numSyms optHeader flags ProcFileHeader .F53 magic verStamp codeSize heapSize bssSize entry codeStart heapStart bssStart gprMask cprMask gpValue ProcAOUTHeader .F54 name physAddr virtAddr size sectionPtr relocPtr lnnoPtr numReloc numLnno flags ProcSectionHeader .F55 fileHeader aoutHeader ProcExecHeader  /users/kupfer/spriteserver/include/user/sprite.h  ./procTypes.h  /users/kupfer/spriteserver/include/sig.h  /users/kupfer/spriteserver/include/sigTypes.h  /users/kupfer/spriteserver/include/rpc.h .F83 paramPtr dataPtr Rpc_ReplyMem  /users/kupfer/spriteserver/include/user/mach.h  /users/kupfer/spriteserver/include/user/status.h  /users/kupfer/spriteserver/include/user/net.h Net_Address ether inet ultra .F76 data generic Net_Address Net_NetworkType Net_Header etherHdr .F77 etherHdr ipHdr inetHdr Net_Header Net_RouteInfo version spriteID interface protocol flags refCount routeID maxBytes minBytes netType netAddress desc hostname machType userData header Net_RouteInfo .F78 data Net_GenericAddress Net_SpriteRoute flags spriteID type .F79 etherHdr data .F80 etherHdr ipHdr inetHdr route Net_SpriteRoute  /users/kupfer/spriteserver/include/user/sprite.h  /users/kupfer/spriteserver/include/user/ds3100.md/machparam.h  /users/kupfer/spriteserver/include/user/ds3100.md/machine/limits.h  /users/kupfer/spriteserver/include/user/netEther.h .F57 byte1 byte2 byte3 byte4 byte5 byte6 Net_EtherAddress .F58 destination source type Net_EtherHdr  /users/kupfer/spriteserver/include/user/ds3100.md/machparam.h  /users/kupfer/spriteserver/include/user/netInet.h Net_InetAddress .F59 hardwareType protocolType hardwareAddrLen protocolAddrLen opcode Net_ArpHeader .F60 header hardwareType protocolType hardwareAddrLen protocolAddrLen opcode senderEtherAddr senderProtAddr targetEtherAddr targetProtAddr Net_ArpPacket .F61 headerLen version typeOfService totalLen ident fragOffset flags timeToLive protocol checksum source dest Net_IPHeader .F62 sour                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    